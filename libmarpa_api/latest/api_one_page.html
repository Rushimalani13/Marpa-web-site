<html lang="en">
<head>
<title>Libmarpa 7.7.0</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Libmarpa 7.7.0">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual (21 January 2015)
is for Libmarpa 7.7.0.

Copyright (C) 2014 Jeffrey Kegler.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation.  A copy of the license is included in the section
     entitled "GNU Free Documentation License."
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">Libmarpa 7.7.0</h1>
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Libmarpa: The Marpa low-level library</a>
<li><a name="toc_Copying" href="#Copying">GNU LESSER GENERAL PUBLIC LICENSE</a>
<li><a name="toc_About-this-document" href="#About-this-document">1 About this document</a>
<ul>
<li><a href="#How-to-read-this-document">1.1 How to read this document</a>
<li><a href="#Prerequisites">1.2 Prerequisites</a>
<li><a href="#Parsing-theory">1.3 Parsing theory</a>
</li></ul>
<li><a name="toc_About-Libmarpa" href="#About-Libmarpa">2 About Libmarpa</a>
<li><a name="toc_Architecture" href="#Architecture">3 Architecture</a>
<ul>
<li><a href="#Major-objects">3.1 Major objects</a>
<li><a href="#Time-objects">3.2 Time objects</a>
<li><a href="#Reference-counting">3.3 Reference counting</a>
<li><a href="#Numbered-objects">3.4 Numbered objects</a>
</li></ul>
<li><a name="toc_Input" href="#Input">4 Input</a>
<ul>
<li><a href="#Earlemes">4.1 Earlemes</a>
<ul>
<li><a href="#The-traditional-model">4.1.1 The traditional model</a>
<li><a href="#The-earleme-variables">4.1.2 The earleme variables</a>
<li><a href="#The-significances-of-the-earleme-variables">4.1.3 The significances of the earleme variables</a>
<li><a href="#The-initial-earleme-settings">4.1.4 The initial earleme settings</a>
<li><a href="#The-standard-model-of-input">4.1.5 The standard model of input</a>
<li><a href="#Ambiguous-input">4.1.6 Ambiguous input</a>
<li><a href="#Variable-length-tokens">4.1.7 Variable length tokens</a>
<li><a href="#The-generalized-model">4.1.8 The generalized model</a>
<li><a href="#General-rules-for-the-earleme-variables">4.1.9 General rules for the earleme variables</a>
</li></ul>
<li><a href="#Terminals">4.2 Terminals</a>
</li></ul>
<li><a name="toc_Semantics" href="#Semantics">5 Semantics</a>
<li><a name="toc_Threads" href="#Threads">6 Threads</a>
<li><a name="toc_Fatal-Errors" href="#Fatal-Errors">7 Fatal Errors</a>
<li><a name="toc_Introduction-to-the-external-interface" href="#Introduction-to-the-external-interface">8 Introduction to the external interface</a>
<ul>
<li><a href="#About-the-overviews">8.1 About the overviews</a>
<li><a href="#Return-values">8.2 Return values</a>
<li><a href="#Naming-conventions">8.3 Naming conventions</a>
</li></ul>
<li><a name="toc_Static-methods" href="#Static-methods">9 Static methods</a>
<li><a name="toc_Configuration-methods" href="#Configuration-methods">10 Configuration methods</a>
<li><a name="toc_Grammar-methods" href="#Grammar-methods">11 Grammar methods</a>
<ul>
<li><a href="#Grammar-overview">11.1 Overview</a>
<li><a href="#Grammar-constructor">11.2 Creating a new grammar</a>
<li><a href="#Grammar-reference-counting">11.3 Tracking the reference count of the grammar</a>
<li><a href="#Symbols">11.4 Symbols</a>
<li><a href="#Rules">11.5 Rules</a>
<li><a href="#Sequences">11.6 Sequences</a>
<li><a href="#Ranks">11.7 Ranks</a>
<li><a href="#Grammar-precomputation">11.8 Precomputing the Grammar</a>
</li></ul>
<li><a name="toc_Recognizer-methods" href="#Recognizer-methods">12 Recognizer methods</a>
<ul>
<li><a href="#Recognizer-overview">12.1 Overview</a>
<li><a href="#Recognizer-constructor">12.2 Creating a new recognizer</a>
<li><a href="#Recognizer-reference-counting">12.3 Keeping the reference count of a recognizer</a>
<li><a href="#Recognizer-life-cycle-mutators">12.4 Life cycle mutators</a>
<li><a href="#Location-accessors">12.5 Location accessors</a>
<li><a href="#Other-parse-status-methods">12.6 Other parse status methods</a>
</li></ul>
<li><a name="toc_Progress-reports" href="#Progress-reports">13 Progress reports</a>
<li><a name="toc_Bocage-methods" href="#Bocage-methods">14 Bocage methods</a>
<ul>
<li><a href="#Bocage-overview">14.1 Overview</a>
<li><a href="#Bocage-constructor">14.2 Creating a new bocage</a>
<li><a href="#Bocage-reference-counting">14.3 Reference counting</a>
<li><a href="#Bocage-accessor">14.4 Accessors</a>
</li></ul>
<li><a name="toc_Ordering-methods" href="#Ordering-methods">15 Ordering methods</a>
<ul>
<li><a href="#Ordering-overview">15.1 Overview</a>
<li><a href="#Ordering-constructor">15.2 Creating an ordering</a>
<li><a href="#Ordering-reference-counting">15.3 Reference counting</a>
<li><a href="#Order-accessor">15.4 Accessors</a>
<li><a href="#Non_002ddefault-ordering">15.5 Non-default ordering</a>
</li></ul>
<li><a name="toc_Tree-methods" href="#Tree-methods">16 Tree methods</a>
<ul>
<li><a href="#Tree-overview">16.1 Overview</a>
<li><a href="#Tree-constructor">16.2 Creating a new tree iterator</a>
<li><a href="#Tree-reference-counting">16.3 Reference counting</a>
<li><a href="#Tree-iteration">16.4 Iterating through the trees</a>
</li></ul>
<li><a name="toc_Value-methods" href="#Value-methods">17 Value methods</a>
<ul>
<li><a href="#Value-overview">17.1 Overview</a>
<li><a href="#How-to-use-the-valuator">17.2 How to use the valuator</a>
<li><a href="#Advantages-of-step_002ddriven-valuation">17.3 Advantages of step-driven valuation</a>
<li><a href="#Maintaining-the-stack">17.4 Maintaining the stack</a>
<ul>
<li><a href="#Sizing-the-stack">17.4.1 Sizing the stack</a>
<li><a href="#Initializing-locations-in-the-stack">17.4.2 Initializing locations in the stack</a>
</li></ul>
<li><a href="#Valuator-constructor">17.5 Creating a new valuator</a>
<li><a href="#Valuator-reference-counting">17.6 Reference counting</a>
<li><a href="#Stepping-through-the-valuator">17.7 Stepping through the valuator</a>
<li><a href="#Valuator-steps-by-type">17.8 Valuator steps by type</a>
<li><a href="#Basic-step-accessors">17.9 Basic step accessors</a>
<li><a href="#Other-step-accessors">17.10 Other step accessors</a>
</li></ul>
<li><a name="toc_Events" href="#Events">18 Events</a>
<ul>
<li><a href="#Events-overview">18.1 Overview</a>
<li><a href="#Event-methods">18.2 Methods</a>
<li><a href="#Event-codes">18.3 Event codes</a>
</li></ul>
<li><a name="toc_Error-methods-macros-and-codes" href="#Error-methods-macros-and-codes">19 Error methods, macros and codes</a>
<ul>
<li><a href="#Error-methods">19.1 Error methods</a>
<li><a href="#Error-Macros">19.2 Error Macros</a>
<li><a href="#External-error-codes">19.3 External error codes</a>
<li><a href="#Internal-error-codes">19.4 Internal error codes</a>
</li></ul>
<li><a name="toc_Design-notes" href="#Design-notes">20 Design notes</a>
<ul>
<li><a href="#Why-so-many-time-objects">20.1 Why so many time objects?</a>
<li><a href="#Design-of-numbered-objects">20.2 Numbered objects</a>
<li><a href="#LHS-Terminals">20.3 LHS terminals</a>
</li></ul>
<li><a name="toc_Work-in-Progress" href="#Work-in-Progress">21 Work in Progress</a>
<ul>
<li><a href="#Untested-methods">21.1 Untested methods</a>
<ul>
<li><a href="#Ranking-methods">21.1.1 Ranking methods</a>
<li><a href="#Zero_002dwidth-assertion-methods">21.1.2 Zero-width assertion methods</a>
<li><a href="#Methods-for-revising-parses">21.1.3 Methods for revising parses</a>
</li></ul>
</li></ul>
<li><a name="toc_Deprecated-techniques-and-methods" href="#Deprecated-techniques-and-methods">22 Deprecated techniques and methods</a>
<ul>
<li><a href="#Valued-and-unvalued-symbols">22.1 Valued and unvalued symbols</a>
<ul>
<li><a href="#What-unvalued-symbols-were">22.1.1 What unvalued symbols were</a>
<li><a href="#Grammar-methods-dealing-with-unvalued-symbols">22.1.2 Grammar methods dealing with unvalued symbols</a>
<li><a href="#Registering-semantics-in-the-valuator">22.1.3 Registering semantics in the valuator</a>
</li></ul>
</li></ul>
<li><a name="toc_GNU-Free-Documentation-License" href="#GNU-Free-Documentation-License">Appendix A GNU Free Documentation License</a>
</li></ul>
</div>



<p><a name="Top"></a>

<h2 class="unnumbered">Libmarpa: The Marpa low-level library</h2>

<p>This manual (21 January 2015)
is for Libmarpa 7.7.0.

   <p>Copyright &copy; 2014 Jeffrey Kegler.

   <blockquote>
Permission is granted to copy, distribute and/or modify this document
under the terms of the <acronym>GNU</acronym> Free Documentation License,
Version 1.3 or any later version published by the Free Software
Foundation. 
A copy of the license is included in the section entitled
&ldquo;<acronym>GNU</acronym> Free Documentation License.&rdquo;
</blockquote>

<p><a name="Copying"></a>

<h2 class="unnumbered">GNU LESSER GENERAL PUBLIC LICENSE</h2>

<!-- The GNU Lesser General Public License. -->
<div align="center">Version 3, 29 June 2007</div>

<!-- This file is intended to be included within another document, -->
<!-- hence no sectioning command or @node. -->
<pre class="display">     Copyright &copy; 2007 Free Software Foundation, Inc. <a href="http://fsf.org/">http://fsf.org/</a>
     
     Everyone is permitted to copy and distribute verbatim copies of this
     license document, but changing it is not allowed.
</pre>
   <p>This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

     <ol type=1 start=0>
<li>Additional Definitions.

     <p>As used herein, &ldquo;this License&rdquo; refers to version 3 of the GNU Lesser
General Public License, and the &ldquo;GNU GPL&rdquo; refers to version 3 of the GNU
General Public License.

     <p>&ldquo;The Library&rdquo; refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

     <p>An &ldquo;Application&rdquo; is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library. 
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

     <p>A &ldquo;Combined Work&rdquo; is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the &ldquo;Linked
Version&rdquo;.

     <p>The &ldquo;Minimal Corresponding Source&rdquo; for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

     <p>The &ldquo;Corresponding Application Code&rdquo; for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

     <li>Exception to Section 3 of the GNU GPL.

     <p>You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

     <li>Conveying Modified Versions.

     <p>If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

          <ol type=a start=1>
<li>under this License, provided that you make a good faith effort to
ensure that, in the event an Application does not supply the
function or data, the facility still operates, and performs
whatever part of its purpose remains meaningful, or

          <li>under the GNU GPL, with none of the additional permissions of
this License applicable to that copy.
          </ol>

     <li>Object Code Incorporating Material from Library Header Files.

     <p>The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

          <ol type=a start=1>
<li>Give prominent notice with each copy of the object code that the
Library is used in it and that the Library and its use are
covered by this License. 
<li>Accompany the object code with a copy of the GNU GPL and this license
document.
          </ol>

     <li>Combined Works.

     <p>You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

          <ol type=a start=1>
<li>Give prominent notice with each copy of the Combined Work that
the Library is used in it and that the Library and its use are
covered by this License. 
<li>Accompany the Combined Work with a copy of the GNU GPL and this license
document. 
<li>For a Combined Work that displays copyright notices during
execution, include the copyright notice for the Library among
these notices, as well as a reference directing the user to the
copies of the GNU GPL and this license document. 
<li>Do one of the following:

               <ol type=1 start=0>
<li>Convey the Minimal Corresponding Source under the terms of this
License, and the Corresponding Application Code in a form
suitable for, and under terms that permit, the user to
recombine or relink the Application with a modified version of
the Linked Version to produce a modified Combined Work, in the
manner specified by section 6 of the GNU GPL for conveying
Corresponding Source. 
<li>Use a suitable shared library mechanism for linking with the
Library.  A suitable mechanism is one that (a) uses at run time
a copy of the Library already present on the user's computer
system, and (b) will operate properly with a modified version
of the Library that is interface-compatible with the Linked
Version.
               </ol>

          <li>Provide Installation Information, but only if you would otherwise
be required to provide such information under section 6 of the
GNU GPL, and only to the extent that such information is
necessary to install and execute a modified version of the
Combined Work produced by recombining or relinking the
Application with a modified version of the Linked Version. (If
you use option 4d0, the Installation Information must accompany
the Minimal Corresponding Source and Corresponding Application
Code. If you use option 4d1, you must provide the Installation
Information in the manner specified by section 6 of the GNU GPL
for conveying Corresponding Source.)
          </ol>

     <li>Combined Libraries.

     <p>You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

          <ol type=a start=1>
<li>Accompany the combined library with a copy of the same work based
on the Library, uncombined with any other library facilities,
conveyed under the terms of this License. 
<li>Give prominent notice with the combined library that part of it
is a work based on the Library, and explaining where to find the
accompanying uncombined form of the same work.
          </ol>

     <li>Revised Versions of the GNU Lesser General Public License.

     <p>The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

     <p>Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License &ldquo;or any later version&rdquo;
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

     <p>If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.

        </ol>

<p><a name="About-this-document"></a>

<h2 class="chapter">1 About this document</h2>

<p><a name="How-to-read-this-document"></a>

<h3 class="section">1.1 How to read this document</h3>

<p>This is essentially a reference document,
but its early chapters lay out concepts
essential to the others. 
Readers will usually want to read the
chapters up and including
<a href="#Introduction-to-the-external-interface">Introduction to the external interface</a>
in order. 
Otherwise, they should follow their interests.

<p><a name="Prerequisites"></a>

<h3 class="section">1.2 Prerequisites</h3>

<p>This document is very far from self-contained. 
It assumes the following:
     <ul>
<li>The reader knows the C programming language
at least well
enough to understand function prototypes and return values. 
<li>The reader
has read the documents for one of Libmarpa's upper layers. 
As of this writing, the only such layer is <code>Marpa::R2</code>
or <code>Marpa::R3</code>,
in Perl. 
<li>The reader knows some parsing theory. 
See <a href="#Parsing-theory">Parsing theory</a>. 
</ul>

<p><a name="Parsing-theory"></a>

<h3 class="section">1.3 Parsing theory</h3>

<p>This document assumes some acquaintance
with parsing theory. 
The reader's
level of knowledge is probably adequate
if he can
answer the following questions,
either immediately or after a little reflection.
     <ul>
<li>What is a BNF rule? 
<li>What is a Marpa sequence rule? 
<li>As a reminder,
Marpa's sequence rules are implemented
as left recursions. 
What does that mean? 
<li>Take a Marpa sequence rule at random. 
What does it look like when rewritten in BNF? 
<li>What does the sequence look like when rewritten
in BNF as a right-recursion? 
</ul>

<p><a name="About-Libmarpa"></a>

<h2 class="chapter">2 About Libmarpa</h2>

<p>Libmarpa implements the Marpa parsing algorithm. 
Marpa is named
after the legendary 11th century Tibetan translator,
Marpa Lotsawa. 
In creating Marpa,
I depended heavily on previous work by Jay Earley,
Joop Leo,
John Aycock and Nigel Horspool.

   <p>Libmarpa implements the entire Marpa algorithm. 
This library does
the necessary grammar preprocessing, recognizes the input,
and produces parse trees. 
It also supports the ordering, iteration
and evaluation of the parse
trees.

   <p>Libmarpa is very low-level. 
For example, it has no strings. 
Rules, symbols, and token values are all represented
by integers. 
This, of course, will not suffice for many applications. 
Users will very often want
names for the symbols, non-integer values for
tokens, or both. 
Typically, applications will use arrays to
translate Libmarpa's integer ID's to strings or other
values as required.

   <p>Libmarpa also does <strong>not</strong> implement most of the semantics. 
Libmarpa does have an evaluator (called a &ldquo;valuator&rdquo;),
but it does <strong>not</strong>
manipulate the stack directly. 
Instead, Libmarpa,
based on its traversal of the parse tree,
passes optimized step by step stack manipulation
instructions to the upper layer. 
These instructions indicate the token or rule involved,
and the proper location for the true token value or
the result of the rule evaluation. 
For rule evaluations, the instructions include the stack location
of the arguments.

   <p>Marpa requires most semantics to be
implemented in the application. 
This allows the application total flexibility. 
It also puts
the application is in a much better position to prevent errors,
to catch errors at runtime or,
failing all else,
to successfully debug the logic.

<p><a name="Architecture"></a>

<h2 class="chapter">3 Architecture</h2>

<p><a name="Major-objects"></a>

<h3 class="section">3.1 Major objects</h3>

<p>The classes of
Libmarpa's object system fall into two types:
major and numbered. 
These are the Libmarpa's major classes,
in sequence.

     <ul>
<li>Configuration:
A configuration object is
a thread-safe way to hold configuration variables,
as well as the return code from failed attempts
to create grammar objects. 
<li>Grammar:
A grammar object contains rules and symbols,
with their properties. 
<li>Recognizer:
A recognizer object reads input. 
<li>Bocage:
A bocage object is a collection of
parse trees, as found by a recognizer. 
Bocages are similar to parse forests. 
<li>Ordering:
An ordering object
is an ordering of the trees
in a bocage. 
<li>Tree:
A tree object is a bocage iterator. 
<li>Value:
A value object is a tree iterator. 
Iteration of tree using a value object
produces &ldquo;steps&rdquo;. 
These &ldquo;steps&rdquo; are
instructions to
the application on how
to evaluate the semantics,
and how to manipulate the stack. 
</ul>

   <p>The major objects have one letter abbreviations,
which are used frequently. 
These are, in the standard sequence,

     <ul>
<li>Configuration:  C
<li>Grammar:  G
<li>Recognizer: R
<li>Bocage: B
<li>Ordering: O
<li>Tree: T
<li>Value: V
</ul>

<p><a name="Time-objects"></a>

<h3 class="section">3.2 Time objects</h3>

<p>All of Libmarpa's major classes,
except the configuration class,
are &ldquo;time&rdquo; classes. 
Except for objects in the grammar class,
all time objects are created from another time
object. 
Each time object is created from a time object
of the class before it in the sequence. 
A recognizer cannot be created without a precomputed grammar;
a bocage cannot be created without a recognizer;
and so on.

   <p>When one time object is used to create a second
time object,
the first time object is the <dfn>parent object</dfn>
and the second time object is the <dfn>child object</dfn>. 
For example, when a bocage is created from a
recognizer,
the recognizer is the parent object,
and the bocage is the child object.

   <p>Grammars have no parent object. 
Every other time object has exactly one parent object. 
Value objects have no child objects. 
All other time objects can have any number of children,
from zero up to a number determined by memory or
some other machine-determined limit.

   <p>Every time object has a <dfn>base grammar</dfn>. 
A grammar object is its own base grammar. 
The base grammar of a recognizer is the grammar
that it was created with. 
The base grammar of any other time object is the base
grammar of its parent object. 
For example,
the base grammar of a bocage is the base
grammar of the recognizer that it was created
with.

<p><a name="Reference-counting"></a>

<h3 class="section">3.3 Reference counting</h3>

<p>Every object in a &ldquo;time&rdquo; class
has its own, distinct, lifetime,
which is controlled by the object's reference count. 
Reference counting follows the usual practice. 
Contexts which take a share of the
&ldquo;ownership&rdquo; of an object
increase the reference count by 1. 
When a context relinquishes its share of
the ownership of an object, it decreases the reference
count by 1.

   <p>Each class of time object has a &ldquo;ref&rdquo; and an &ldquo;unref&rdquo;
method, to be used by those contexts which need to
explicitly increment and decrement the reference count. 
For example, the &ldquo;ref&rdquo; method for the grammar class is
<code>marpa_g_ref()</code>
and the &ldquo;unref&rdquo; method for the grammar class is
<code>marpa_g_unref()</code>.

   <p>Time objects do not have explicit destructors. 
When the reference count of a time object reaches
0, that time object is destroyed.

   <p>Much of the necessary reference counting
is performed automatically. 
The context calling the constructor of a time object
does not need to explicitly increase the reference
count, because
Libmarpa time objects are
always created with a reference count of 1.

   <p>Child objects &ldquo;own&rdquo; their parents,
and when a child object is successfully created,
the reference count of its parent object is
automatically incremented to reflect this. 
When a child object is destroyed, it
automatically decrements the reference count of its parent.

   <p>In a typical application, a calling context needs only
to remember
to &ldquo;unref&rdquo; each time object that it creates,
once it is finished with that time object. 
All other reference decrements and increments are taken
care of automatically. 
The typical application never needs to explicitly
call one of the &ldquo;ref&rdquo; methods.

   <p>More complex applications may find it convenient
to have one or more contexts share ownership of objects
created in another context. 
These more complex situations
are the only cases in which the &ldquo;ref&rdquo; methods
will be needed.

<p><a name="Numbered-objects"></a>

<h3 class="section">3.4 Numbered objects</h3>

<p>In addition to its major, &ldquo;time&rdquo; objects, Libmarpa also has
numbered objects. 
Numbered objects do not have lifetimes of their own. 
Every numbered object belongs to a time object,
and is destroyed with it. 
Rules and symbols are numbered objects. 
Tokens values are another class of numbered
objects.

<p><a name="Input"></a>

<h2 class="chapter">4 Input</h2>

<p><a name="Earlemes"></a>

<h3 class="section">4.1 Earlemes</h3>

<p><a name="The-traditional-model"></a>

<h4 class="subsection">4.1.1 The traditional model</h4>

<p>In traditional Earley parsers, the concept of location is very simple. 
Locations are numbered from 0 to <var>n</var>, where <var>n</var> is the length of
the input. 
Every location has an Earley set, and vice versa. 
Location 0 is the start location. 
Every location after the start location has exactly one input token
associated with it.

   <p>Some applications
do not fit this traditional input model &mdash;
natural language processing requires ambiguous tokens,
for example. 
Libmarpa allows a wide variety of alternative input models.

   <p>This document assumes that the reader knows the concepts
behind Libmarpa's
alternative input models, either from the documentation
of a higher level interface, such as
<code>Marpa::XS</code>,
<code>Marpa::R2</code>,
or <code>Marpa::R3</code>,
or from Marpa's
<a href="https://docs.google.com/file/d/0B9_mR_M2zOc4Ni1zSW5IYzk3TGc/edit?usp=sharing">theory document</a>.

   <p>As a reminder,
in Libmarpa a location is called a <dfn>earleme</dfn>. 
The number of an Earley set is the <dfn>ID of the Earley set</dfn>,
or its <dfn>ordinal</dfn>. 
In the traditional model, the ordinal of an Earley set and
its earleme are always exactly the same, but in Libmarpa
they will be different.

<p><a name="The-earleme-variables"></a>

<h4 class="subsection">4.1.2 The earleme variables</h4>

<p>The important earleme variables are the current earleme, the furthest earleme
and the latest earleme. 
The <dfn>current earleme</dfn> is the earleme that Libmarpa is currently working on. 
More specifically, it is the one at which new tokens will <strong>start</strong>. 
Since tokens are never zero length, a new token will always end after the
current earleme. 
The current earleme is initially earleme 0. 
Every call to <code>marpa_r_earleme_complete()</code> advances the
current earleme by 1.

   <p>The <dfn>furthest earleme</dfn> is the highest numbered (and therefore &ldquo;furthest&rdquo;)
earleme at which a token ends. 
The furthest earleme is initially earleme 0. 
With every call to <code>marpa_r_alternative()</code>, the end of the token
it adds is calculated. 
A token ends at the earleme location <var>current</var>+<var>length</var>,
where <var>current</var> is the current earleme,
and <var>length</var> is the length of the newly added token. 
After a call to <code>marpa_r_alternative()</code>,
the furthest earleme is its value before the call,
or <var>current</var>+<var>length</var>,
whichever is greater.

   <p>The <dfn>latest earleme</dfn> is the earleme of the latest
Earley set. 
The <dfn>latest Earley set</dfn> is the last Earley set completed. 
This is always the highest numbered Earley set. 
If there is an Earley set at the current earleme,
it is the latest Earley set and the latest earleme
is equal to the current earleme. 
There is never an Earley set after the current earleme.

   <p>After every call to the <code>marpa_r_earleme_complete()</code> method
that adds a token,
the value of the latest earleme is
same as the value of the current earleme. 
After every call to the <code>marpa_r_earleme_complete()</code> method
that does <strong>not</strong> add a token,
the value of the latest earleme is unchanged
from its value before the call.

<p><a name="The-significances-of-the-earleme-variables"></a>

<h4 class="subsection">4.1.3 The significances of the earleme variables</h4>

<p>The current earleme tracks the advance of the recognizer through the input. 
Input tokens always start at the current earleme. 
An application can advance past the current earleme,
by calling <code>marpa_r_earleme_complete()</code>, which
increments the current earleme by 1. 
After initialization,
<code>marpa_r_earleme_complete()</code> is
the only way to manipulate the value of the current earleme.

   <p>The furthest earleme tracks how &ldquo;far out&rdquo; tokens can be found. 
In the standard input model, calling
<code>marpa_r_earleme_complete()</code> after each
<code>marpa_r_alternative()</code> call is sufficient to process
all inputs,
and the furthest earleme's value
can be typically be ignored. 
In alternative input models, if tokens have lengths greater than
1, calling
<code>marpa_r_earleme_complete()</code> once after the last token
is read may not be enough to ensure that all tokens have been processed. 
To ensure that all tokens have been processed,
an application must advance the current earleme
by calling <code>marpa_r_earleme_complete()</code>,
until the current earleme is equal to the furthest earleme.

   <p>The lastest earleme is the earleme of the last Earley set. 
The latest earleme is different from the current earleme if and only if
there is no Earley set at the current earleme. 
A different end of parsing can be specified,
but by default, parsing is of the input
in the range
from earleme 0 to the latest earleme.

<p><a name="The-initial-earleme-settings"></a>

<h4 class="subsection">4.1.4 The initial earleme settings</h4>

<p>All input models have the same initial values. 
Initially the current, latest and furthest earleme
are always earleme 0.

   <p>Understanding the
settings of current, latest and furthest earleme is
crucial to working with advanced input models,
and for this reason the next sections will go
through the possibilities carefully. 
The presentation will start with the most traditional
and restrictive models. 
It will proceed to less restrictive models.

<p><a name="The-standard-model-of-input"></a>

<h4 class="subsection">4.1.5 The standard model of input</h4>

<p>In the standard model of input,
calls to <code>marpa_r_alternative()</code>
and <code>marpa_r_earleme_complete()</code> are
made in pairs. 
There is, first, exactly one call
to <code>marpa_r_alternative()</code>,
and it is for a token with length 1. 
Following it must be a call
to <code>marpa_r_earleme_complete()</code>. 
For an input of length <var>n</var>, there will be
exactly <var>n</var> such paired calls.

   <p>Suppose, in the standard model that,
for a call
to <code>marpa_r_alternative()</code>,
the following is true:
     <ul>
<li>The current earleme before the call was <var>c</var>. 
</ul>
   Because this is the standard model,
this means that we also know that
     <ul>
<li>The latest earleme before the call was <var>c</var>. 
<li>The furthest earleme before the call was <var>c</var>. 
</ul>
   In that case,
after the call to
<code>marpa_r_alternative()</code>,
the following will be true:
     <ul>
<li>The current earleme will still be <var>c</var>. 
<li>The latest earleme will still be <var>c</var>. 
<li>The furthest earleme will be <var>c</var>+1. 
</ul>

   <p>Suppose, in the standard model that,
for a call
to <code>marpa_r_earleme_complete()</code>,
the following is true:
     <ul>
<li>The current earleme before the call is <var>c</var>. 
</ul>
   Because this is the standard model,
this means that we also know that
     <ul>
<li>The latest earleme before the call was <var>c</var>. 
<li>The furthest earleme before the call was <var>c+1</var>. 
</ul>
   In that case,
after the call
to <code>marpa_r_earleme_complete()</code>,
the current, latest and furthest earlemes will
be the same. 
Specifically,
the following will be true:
     <ul>
<li>The current earleme will be advanced to <var>c+1</var>. 
<li>The latest earleme will be advanced to <var>c+1</var>. 
<li>The furthest earleme will remain at <var>c+1</var>. 
</ul>

<p><a name="Ambiguous-input"></a>

<h4 class="subsection">4.1.6 Ambiguous input</h4>

<p>As a first loosening of the standard model,
we no longer require calls to <code>marpa_r_alternative()</code>
to be paired with calls to
<code>marpa_r_earleme_complete()</code>. 
Instead,
we allow a series of one or more calls
to <code>marpa_r_alternative()</code>
before each call to
<code>marpa_r_earleme_complete()</code>. 
We still require that there be at least one call
to <code>marpa_r_alternative()</code>
before each call to
<code>marpa_r_earleme_complete()</code>,
and we still require that all tokens have
a length of 1.

   <p>In the ambiguous input model, the behavior of the current,
latest and furthest earlemes are exactly
as described for the standard model, with one minor
exception:
Where the current earleme is <var>c</var>,
and a call to <code>marpa_r_alternative()</code> is not the first
of a series,
the value of the furthest earleme before the call will be
<var>c</var>+1.

<p><a name="Variable-length-tokens"></a>

<h4 class="subsection">4.1.7 Variable length tokens</h4>

<p>Our next loosening of the restrictions is to allow
variable length tokens. 
That is, instead of requiring that all tokens
be of length 1,
we allow tokens to be of length 1 or longer. 
This does change the behavior of the earleme variables.

   <p>Suppose, in the variable length token model that,
for a call
to <code>marpa_r_alternative()</code>,
the following is true:
     <ul>
<li>The current earleme before the call was <var>c</var>. 
In this model, this means that
the latest earleme before the call is also <var>c</var>. 
<li>The furthest earleme before the call was <var>old_f</var>. 
<li>The length of the token is <var>length</var>. 
</ul>
   In that case,
after the call to
<code>marpa_r_alternative()</code>,
the following will be true:
     <ul>
<li>The current and latest earlemes will still be <var>c</var>. 
The current and latest earlemes are never changed by a call
to <code>marpa_r_alternative()</code>. 
<li>The furthest earleme will be either <var>old_f</var> or
 <var>c</var>+<var>length</var>, whichever was greater. 
</ul>

   <p>Suppose, in the variable length token model that,
for a call
to <code>marpa_r_earleme_complete()</code>,
the following is true:
     <ul>
<li>The current earleme before the call is <var>c</var>. 
In this model, this means that
the latest earleme before the call is also <var>c</var>. 
<li>The furthest earleme before the call is <var>old_f</var>. 
</ul>
   In that case,
after the call
to <code>marpa_r_earleme_complete()</code>,
the following will be true:
     <ul>
<li>The current earleme will be advanced to <var>c+1</var>. 
<li>The latest earleme will also be <var>c+1</var>. 
<li>The furthest earleme will still be <var>old_f</var>. 
The furthest earleme is never changed by a call
to <code>marpa_r_earleme_complete()</code>. 
</ul>

<p><a name="The-generalized-model"></a>

<h4 class="subsection">4.1.8 The generalized model</h4>

<p>To fully generalize the input model,
we now need to remove only one restriction. 
We now allow empty earlemes &mdash; earlemes with
no tokens and no Earley set. 
For the generalized input model,
the effect on the earleme variables of
a call
to <code>marpa_r_alternative()</code> is exactly
the same as it is for the variable length input model. 
The effect on the earleme variables of a call to
to <code>marpa_r_earleme_complete()</code> depends on
whether or not that call creates an empty earleme. 
A call
to <code>marpa_r_earleme_complete()</code>
creates an empty earleme if and only if
it falls into one of these two cases:
     <ul>
<li>There has been no call
to <code>marpa_r_alternative()</code> since
recognizer initialization. 
<li>There has been no call
to <code>marpa_r_alternative()</code> since
the previous call
to <code>marpa_r_earleme_complete()</code>. 
</ul>

   <p>Suppose, in the generalized input model that,
for a call
to <code>marpa_r_earleme_complete()</code>
that creates an empty earleme,
the following is true:
     <ul>
<li>The current earleme before the call is <var>c</var>. 
<li>The latest earleme before the call is <var>old_l</var>. 
<li>The furthest earleme before the call is <var>old_f</var>. 
</ul>
   In that case,
after the call
to <code>marpa_r_earleme_complete()</code>,
the following will be true:
     <ul>
<li>The current earleme will be advanced to <var>c+1</var>. 
<li>The latest earleme will remain at <var>old_l</var>. 
This means that the latest earleme will be less than
the current earleme. 
<li>The furthest earleme will remain at <var>old_f</var>. 
The furthest earleme is never changed by a call
to <code>marpa_r_earleme_complete()</code>. 
</ul>

   <p>Suppose, in the generalized input model that,
for a call
to <code>marpa_r_earleme_complete()</code>
that does not creates an empty earleme,
the following is true:
     <ul>
<li>The current earleme before the call is <var>c</var>. 
<li>The latest earleme before the call is <var>old_l</var>. 
<li>The furthest earleme before the call is <var>old_f</var>. 
</ul>
   In that case,
after the call
to <code>marpa_r_earleme_complete()</code>,
the following will be true:
     <ul>
<li>The current earleme will be advanced to <var>c+1</var>. 
<li>The latest earleme will be advanced to <var>c+1</var>. 
<li>The furthest earleme will remain at <var>old_f</var>. 
The furthest earleme is never changed by a call
to <code>marpa_r_earleme_complete()</code>. 
</ul>

<p><a name="General-rules-for-the-earleme-variables"></a>

<h4 class="subsection">4.1.9 General rules for the earleme variables</h4>

<p>At this point, the most generalized input model has been
introduced. 
Here are some useful facts about the earleme variables that will always be the case,
no matter which of the input models is in use.

     <ul>
<li>The current earleme is always greater than
or equal to the latest earleme. 
<li>The furthest earleme is always greater than
or equal to the latest earleme. 
<li>If the furthest earleme is greater than the current earleme,
the parser is not exhausted. 
<li>If the furthest earleme is less than the current earleme,
the parser is exhausted. 
</ul>

   <p>If the parser is not exhausted,
the following will always be true,
no matter which of the input models is in use.

     <ul>
<li>The furthest earleme is greater than
or equal to the current earleme. 
</ul>

   <p>In an exhausted parser, the following will always be true,
no matter which of the input models is in use.

     <ul>
<li>The furthest earleme is less than
or equal to the current earleme. 
</ul>

<p><a name="Terminals"></a>

<h3 class="section">4.2 Terminals</h3>

<p>A terminal symbol is a symbol which
may appear in the input. 
Traditionally,
all LHS symbols, as well as
the start symbol, must be non-terminals. 
This is Marpa's behavior, by default.

   <p>Marpa allows the user to eliminate the distinction
between terminals and non-terminals. 
In this, it
differs from traditional parsers. 
A Libmarpa
can arrange for a a terminal
to appear on the LHS of one or more rules,
or for a terminal to be the start symbol. 
However,
since terminals can never be zero length,
it is a logical contradiction for a nulling
symbol to also be a terminal
and Marpa does not allow it.

   <p>Token values are <code>int</code>'s. 
Libmarpa does nothing with token values except accept
them from the application and return them during
parse evaluation.

<p><a name="Semantics"></a>

<h2 class="chapter">5 Semantics</h2>

<p>Libmarpa handling of semantics is unusual. 
Most semantics are left up to the application,
but Libmarpa guides them. 
Specifically, the application is expected to maintain the evaluation
stack. 
Libmarpa's valuator provides instructions on how to handle the stack. 
Libmarpa's stack handling instructions
are called &ldquo;steps&rdquo;. 
For example, a Libmarpa step might tell the application that the value
of a token needs to go into a certain stack position. 
Or a Libmarpa step might tell the application that a rule is to be evaluated. 
For rule evalution, Libmarpa will tell the application where the operands
are to be found,
and where the result must go.

   <p>The detailed discussion of
Libmarpa's handling of semantics is in the reference chapters
of this document,
under the appropriate methods and classes. 
The most extensive discussion of the semantics
is in the section that deals with the methods of the value time class. 
See <a href="#Value-methods">Value methods</a>.

<p><a name="Threads"></a>

<h2 class="chapter">6 Threads</h2>

<p>Libmarpa is thread-safe,
given circumstances as described below. 
The Libmarpa methods are not reentrant.

   <p>Libmarpa is C89-compliant. 
It uses no global data,
and calls only the routines
that are defined in the C89 standard
and that can be made thread-safe. 
In most modern implementations,
the default C89 implementation is thread-safe
to the extent possible. 
But the C89 standard does not require thread-safety,
and even most modern environments allow the user
to turn thread safety off. 
To be thread-safe, Libmarpa must be compiled
and linked in an environment that provides
thread-safety.

   <p>While Libmarpa can be used safely across
multiple threads,
a Libmarpa grammar cannot be. 
Further, a Libmarpa time object can
only be used safely in the same thread
as its base grammar. 
This is because all
time objects with the same base grammar share data
from that base grammar.

   <p>To work around this limitation,
the same grammar definition can be
used to a create a new
Libmarpa grammar
time object in each thread. 
If there is sufficient interest, future versions of
Libmarpa could allow thread-safe
cloning of grammars and other
time objects.

<p><a name="Fatal-Errors"></a>

<h2 class="chapter">7 Fatal Errors</h2>

<p>Libmarpa avoids fatal errors,
leaving that decision up to the application,
with one exception. 
Currently, if <code>malloc</code> fails to allocate memory,
Libmarpa terminates the program with a fatal error.

   <p>While this is in keeping with current practice,
future versions of Libmarpa are likely to both allow
an alternative memory allocator to be specified,
and to allow the user to specifier a handler to
be called when an out-of-memory condition occurs.

<p><a name="Introduction-to-the-external-interface"></a>

<h2 class="chapter">8 Introduction to the external interface</h2>

<p>The following chapters describe Libmarpa's external
interface in detail.

<p><a name="About-the-overviews"></a>

<h3 class="section">8.1 About the overviews</h3>

<p>The reference sections for each major class begin with an overview. 
These sections name the
most important Libmarpa methods
in the order in which they are typically used,
and very briefly describe their purpose. 
The overviews are intended as &ldquo;cheat sheets&rdquo;.

   <p>The overview sections often speak of
an &ldquo;archetypal&rdquo; application. 
The archetypal Libmarpa application
implements a complete logic flow,
starting with the creation of a grammar,
and proceeding all the way
to the return of the final result from a value object. 
In the archetypal Libmarpa application,
the grammar, input and semantics are
all small but non-trivial.

<p><a name="Return-values"></a>

<h3 class="section">8.2 Return values</h3>

<p>Return values are discussed method by method,
but some general practices are worth
mentioning. 
For methods that return an integer,
Libmarpa usually reserves &minus;1 for special purposes,
such as indicating loop termination in an iterator. 
In Libmarpa, methods usually indicate failure
by returning &minus;2. 
Any result greater than &minus;2 usually indicates success.

   <p>If a method returns an pointer value,
<code>NULL</code> usually indicates failure. 
Any other result usually indicates success.

   <p>On failure, a Libmarpa method always sets
the error code. 
On success, a Libmarpa method may take
one of three actions:
     <ul>
<li>Set
an informational error code. 
<li>Leave
the error code as it is. 
<li>Reset the error code to <code>MARPA_ERROR_NONE</code>. 
</ul>

   <p>Which of the three actions the method
takes on success
should be regarded as unspecified,
unless stated in the description of the method
in this document. 
If a method sets an informational error code on
success, that will always be stated in
its description, and the description will
specify,
for each informational error code,
the specific error code value,
the circumstances under which it is set,
and what return values will accompany it.

   <p>Informational error codes are set
because some applications may find them convenient. 
Typically information error codes are redundant information,
which may be ignored.

   <p>A method can have many reasons for
failing, and many of the reasons
for failure are common to
large number of methods. 
Full descriptions of the error codes
that are returned by the external methods
are given in their own section. 
See <a href="#External-error-codes">External error codes</a>.

<p><a name="Naming-conventions"></a>

<h3 class="section">8.3 Naming conventions</h3>

<p>Methods in Libmarpa follow a strict naming convention. 
All methods have a name beginning with <code>marpa_</code>,
if they are part of the
external interface. 
If an external method is not a static method,
its name is prefixed with one of
<code>marpa_c_</code>,
<code>marpa_g_</code>,
<code>marpa_r_</code>,
<code>marpa_b_</code>,
<code>marpa_o_</code>,
<code>marpa_t_</code> or
<code>marpa_v_</code>,
where the single letter between underscores
is one of the Libmarpa major class abbreviations. 
The letter indicates which class
the method belongs to.

   <p>Methods that are exported,
but that are part of
the internal interface,
begin with <code>_marpa_</code>. 
Methods that are part of the internal interface
(often called &ldquo;internal methods&rdquo;)
are subject to change and are intended for use
only by Libmarpa's developers.

   <p>Libmarpa reserves the <code>marpa_</code>
and <code>_marpa_</code> prefixes for itself,
with all their capitalization variants. 
All Libmarpa names visible outside the package
will begin with a capitalization variant
of one of these two prefixes.

<p><a name="Static-methods"></a>

<h2 class="chapter">9 Static methods</h2>

<div class="defun">
&mdash; Function: Marpa_Error_Code <b>marpa_check_version</b> (<var>int required_major, int required_minor, int required_micro </var>)<var><a name="index-marpa_005fcheck_005fversion-1"></a></var><br>
<blockquote>
        <p>Checks that the Marpa library in use is compatible with the
given version. Generally you will pass in the constants
<code>MARPA_MAJOR_VERSION</code>,
<code>MARPA_MINOR_VERSION</code>,
<code>MARPA_MICRO_VERSION</code>
as the three arguments to this function; that produces
a check that the library in use is compatible with
the version of Libmarpa the application or module was compiled
against. 
Compatibility is defined by two things:
first the version
of the running library is newer than the version
<var>required_major</var>.<var>required_minor</var>.<var>required_micro</var>. 
Second
the running library must be binary compatible with the
version
<var>required_major</var>.<var>required_minor</var>.<var>required_micro</var>
(same major version.)

        <p>Return value: <code>MARPA_ERR_NONE</code> if the Marpa library is compatible with the
requested version.  If the library is not compatible,
one of the following is returned, indicating the nature of the mismatch:
          <ul>
<li><code>MARPA_ERR_MAJOR_VERSION_MISMATCH</code>,
<li><code>MARPA_ERR_MINOR_VERSION_MISMATCH</code>
<li><code>MARPA_ERR_MICRO_VERSION_MISMATCH</code>
</ul>

     </blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Error_Code <b>marpa_version</b> (<var>int* version</var>)<var><a name="index-marpa_005fversion-2"></a></var><br>
<blockquote>
        <p>Returns the version number in <var>version</var>,
which must have room for three <code>int</code>'s.

        <p>Return value: A non-negative number on success,
&minus;2 on failure. 
</p></blockquote></div>

<p><a name="Configuration-methods"></a>

<h2 class="chapter">10 Configuration methods</h2>

<p>The configuration object is intended for future extensions. 
These may
allow the application to override Libmarpa's memory allocation
and fatal error handling without resorting to global
variables, and therefore in a thread-safe way. 
Currently, the only function of the <code>Marpa_Config</code>
class is to give <code>marpa_g_new()</code>
a place to put its error code.

   <p><code>Marpa_Config</code> is Libmarpa's only &ldquo;major&rdquo;
class which is not a time class. 
There is no constructor or destructor, although
<code>Marpa_Config</code> objects <strong>do</strong> need to be initialized
before use. 
Aside from its own accessor,
<code>Marpa_Config</code> objects are only used by <code>marpa_g_new</code>
and no reference to their location is not kept
in any of Libmarpa's time objects. 
The intent is to that it be convenient
to have them in memory that might be deallocated
soon after <code>marpa_g_new</code> returns. 
For example, they could be put on the stack.

<div class="defun">
&mdash; Function: int <b>marpa_c_init</b> (<var> Marpa_Config* config</var>)<var><a name="index-marpa_005fc_005finit-3"></a></var><br>
<blockquote>
        <p>Initialize the <var>config</var> information to &ldquo;safe&rdquo; default
values. 
Unspecified behavior will result
if an initialized
configuration is used to create a grammar.

        <p>Return value: A non-negative value.  Always succeeds. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Error_Code <b>marpa_c_error</b> (<var> Marpa_Config* config, const char** p_error_string </var>)<var><a name="index-marpa_005fc_005ferror-4"></a></var><br>
<blockquote>
        <p>Error codes are usually kept in the base grammar,
which leaves <code>marpa_g_new()</code> no place to put
its error code on failure. 
Objects of
the <code>Marpa_Config</code> class provide such a place.

        <p>Return value:
The error code in <var>config</var>. 
Always succeeds. 
</p></blockquote></div>

<p><a name="Grammar-methods"></a>

<h2 class="chapter">11 Grammar methods</h2>

<p><a name="index-grammars-5"></a>

<p><a name="Grammar-overview"></a>

<h3 class="section">11.1 Overview</h3>

<p>An archtypal application has a grammar. 
To create a grammar, use the <code>marpa_g_new()</code> method. 
When a grammar is no longer in use, its memory can be freed
using the
<code>marpa_g_unref()</code> method.

   <p>To be precomputed,
a grammar must have one or more symbols. 
To create symbols, use the
<code>marpa_g_symbol_new()</code> method.

   <p>To be precomputed,
a grammar must have one or more rules. 
To create rules, use the
<code>marpa_g_rule_new()</code> and
<code>marpa_g_sequence_new()</code> methods.

   <p>For non-trivial parsing,
one or more of the symbols must be terminals. 
To mark a symbol as a terminal,
use the
<code>marpa_g_symbol_is_terminal_set()</code> method.

   <p>To be precomputed,
a grammar must have exactly one start symbol. 
To mark a symbol as the start symbol,
use the
<code>marpa_g_start_symbol_set()</code> method.

   <p>Before parsing with a grammar, it must be precomputed. 
To precompute a grammar,
use the
<code>marpa_g_precompute()</code> method.

<p><a name="Grammar-constructor"></a>

<h3 class="section">11.2 Creating a new grammar</h3>

<p><a name="index-grammar-constructor-6"></a>

<div class="defun">
&mdash; Function: Marpa_Grammar <b>marpa_g_new</b> (<var> Marpa_Config* configuration </var>)<var><a name="index-marpa_005fg_005fnew-7"></a></var><br>
<blockquote>
        <p>Creates a new grammar time object. 
The returned grammar object is not yet precomputed,
and will have no symbols and rules. 
Its reference count will be 1.

        <p>Unless the application calls <code>marpa_c_error</code>,
Libmarpa will not reference the location
pointed to by the <var>configuration</var>
argument after <code>marpa_g_new</code> returns. 
The <var>configuration</var> argument may be <code>NULL</code>,
but if it is,
there will be no way to determine
the error code on failure.

        <p>Return value: On success, the grammar object. 
On failure, <code>NULL</code>,
and the error code is set in <var>configuration</var>.

        </blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_force_valued</b> (<var> Marpa_Grammar g </var>)<var><a name="index-marpa_005fg_005fforce_005fvalued-8"></a></var><br>
<blockquote>
        <p>It is recommended that
this call be made immediately after the
grammar constructor. 
It turns off a deprecated feature.

        <p>The <code>marpa_g_force_valued</code> forces all the
symbols in a grammar to be &ldquo;valued&rdquo;. 
The opposite of a valued symbol is one about whose value
you do not care. 
This distinction has been made in the past in hope
of gaining efficiencies at evaluation time. 
Current thinking is that the gains do not repay the extra
complexity.

        <p>Return value: On success, a non-negative integer. 
On failure, a negative integer. 
</p></blockquote></div>

<p><a name="Grammar-reference-counting"></a>

<h3 class="section">11.3 Tracking the reference count of the grammar</h3>

<p><a name="index-grammar-destructor-9"></a><a name="index-grammar-reference-10"></a><a name="index-grammar-reference-count-11"></a>

<div class="defun">
&mdash; Function: Marpa_Grammar <b>marpa_g_ref</b> (<var>Marpa_Grammar g</var>)<var><a name="index-marpa_005fg_005fref-12"></a></var><br>
<blockquote><p>Increases the reference count by 1. 
Not needed by most applications.

        <p>Return value:
On success, the grammar object it was called with;
<code>NULL</code> on failure.

        </blockquote></div>

<div class="defun">
&mdash; Function: void <b>marpa_g_unref</b> (<var>Marpa_Grammar g</var>)<var><a name="index-marpa_005fg_005funref-13"></a></var><br>
<blockquote><p>Decreases the reference count by 1,
destroying <var>g</var> once the reference count reaches
zero.

        </blockquote></div>

<p><a name="Symbols"></a>

<h3 class="section">11.4 Symbols</h3>

<div class="defun">
&mdash; Function: Marpa_Symbol_ID <b>marpa_g_start_symbol</b> (<var>Marpa_Grammar g</var>)<var><a name="index-marpa_005fg_005fstart_005fsymbol-14"></a></var><br>
<blockquote>
        <p>Returns current value of the start symbol of grammar <var>g</var>. 
The value is that
specified in the <code>marpa_g_start_symbol_set()</code> call,
if there has been one.

        <p>Return value:
On failure, &minus;2;
&minus;1 if there is no start symbol yet;
otherwise the ID of the new start symbol. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Symbol_ID <b>marpa_g_start_symbol_set</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID sym_id</var>)<var><a name="index-marpa_005fg_005fstart_005fsymbol_005fset-15"></a></var><br>
<blockquote>
        <p>Sets the start symbol of grammar <var>g</var> to symbol <var>id</var>.

        <p>Return value: On success, the ID of the new start symbol. 
If <var>sym_id</var> is well-formed, but there is no
such symbol, -1. 
On failure, &minus;2.

        </blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_highest_symbol_id</b> (<var>Marpa_Grammar g</var>)<var><a name="index-marpa_005fg_005fhighest_005fsymbol_005fid-16"></a></var><br>
<blockquote><p>Return value: On success, the numerically largest symbol ID
of <var>g</var>. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_symbol_is_accessible</b> (<var>Marpa_Grammar g, Marpa_Symbol_ID sym_id</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005faccessible-17"></a></var><br>
<blockquote><p>A symbol is <dfn>accessible</dfn> if it can be reached from the start symbol.

        <p>Return value: On success, 1 if symbol <var>sym_id</var> is accessible, 0 if not. 
If <var>sym_id</var> is well-formed, but there is no
such symbol, -1. 
If the grammar is not precomputed, or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_symbol_is_completion_event</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID sym_id</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fcompletion_005fevent-18"></a></var><br>
&mdash; Function: int <b>marpa_g_symbol_is_completion_event_set</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID sym_id, int value</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fcompletion_005fevent_005fset-19"></a></var><br>
<blockquote>
        <p>Libmarpa can be set up to generate an
<code>MARPA_EVENT_SYMBOL_COMPLETED</code>
event whenever the symbol is completed. 
A symbol is said to be <strong>completed</strong>
when a non-nulling rule with
that symbol on its LHS is completed.

        <p>For completion events to occur, the symbol must be marked
as a completion event symbol. 
The <code>marpa_g_symbol_is_completion_event_set()</code> function
marks symbol <var>sym_id</var> as a completion event symbol
if <var>value</var> is 1,
and unmarks it
it as a completion event symbol if <var>value</var> is 0. 
The <code>marpa_g_symbol_is_completion_event()</code> method
returns the current value of the completion event marking
for symbol <var>sym_id</var>.

        <p>Nulled rules and symbols will never cause completion events. 
Nullable symbols
may be marked as completion event symbols,
but this will have an effect only when the symbol
is not nulled. 
Nulling symbols
may be marked as completion event symbols,
but no completion events will ever be generated
for a nulling symbol. 
Note that this implies at no completion event will
ever be generated at earleme 0,
the start of parsing.

        <p>The completion event marking cannot be changed once
the grammar is precomputed. 
However, if a symbol is marked as a completion event symbol,
it can be deactivated
and reactivated in the recognizer.

        <p>Success: On success, 1 if symbol <var>sym_id</var>
is a completion event symbol after the
call, 0 otherwise.

        <p>Failures:
If <var>sym_id</var> is well-formed, but there is no
such symbol, -1. 
if the grammar <var>g</var> is precomputed;
or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_symbol_is_nulled_event</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID sym_id</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fnulled_005fevent-20"></a></var><br>
&mdash; Function: int <b>marpa_g_symbol_is_nulled_event_set</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID sym_id, int value</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fnulled_005fevent_005fset-21"></a></var><br>
<blockquote>
        <p>Libmarpa can set up to generate
an <code>MARPA_EVENT_SYMBOL_NULLED</code>
event whenever the symbol is nulled. 
A symbol is said to be <strong>nulled</strong>
when a zero length instance of that symbol
is recognized.

        <p>For nulled events to occur, the symbol must be marked
as a nulled event symbol. 
The <code>marpa_g_symbol_is_nulled_event_set()</code> function
marks symbol <var>sym_id</var> as a nulled event symbol
if <var>value</var> is 1,
and unmarks it
it as a nulled event symbol if <var>value</var> is 0. 
The <code>marpa_g_symbol_is_nulled_event()</code> method
returns the current value of the nulled event marking
for symbol <var>sym_id</var>.

        <p>When a symbol is recognized, it can generate
a nulled event or a completion event,
but recognition of a single instance of a symbol will
generate at most one or the other event &ndash; never
both. 
Symbols recognized
as zero length can only generate nulled events. 
Symbols recognized
as non-zero in length can only generate completed events.

        <p>Zero length derivations can be ambiguous. 
When a zero length symbol is recognized,
all of its zero-length derivations are also considered to be
recognized.

        <p>The nulled event marking cannot be changed once
the grammar is precomputed. 
However, if a symbol is marked as a nulled event symbol,
it can be deactivated
and reactivated in the recognizer.

        <p>Success: On success, 1 if symbol <var>sym_id</var>
is a nulled event symbol after the
call, 0 otherwise.

        <p>Failures:
If <var>sym_id</var> is well-formed, but there is no
such symbol, -1. 
if the grammar <var>g</var> is precomputed;
or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_symbol_is_nullable</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID sym_id</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fnullable-22"></a></var><br>
<blockquote><p>A symbol is <dfn>nullable</dfn> if it sometimes produces the empty string. 
A <strong>nulling</strong> symbol is always a <strong>nullable</strong> symbol,
but not all <strong>nullable</strong> symbols are <strong>nulling</strong> symbols.

        <p>Return value: On success, 1 if symbol <var>sym_id</var> is nullable, 0 if not. 
If <var>sym_id</var> is well-formed, but there is no
such symbol, -1. 
If the grammar is not precomputed, or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_symbol_is_nulling</b> (<var>Marpa_Grammar g, Marpa_Symbol_ID sym_id</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fnulling-23"></a></var><br>
<blockquote><p>A symbol is <dfn>nulling</dfn> if it always produces the empty string.

        <p>Return value: On success, 1 if symbol <var>sym_id</var> is nulling, 0 if not. 
If <var>sym_id</var> is well-formed, but there is no
such symbol, -1. 
If the grammar is not precomputed, or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_symbol_is_productive</b> (<var>Marpa_Grammar g, Marpa_Symbol_ID sym_id</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fproductive-24"></a></var><br>
<blockquote><p>A symbol is <dfn>productive</dfn> if it can produce a string of terminals. 
All nullable symbols are considered productive.

        <p>Return value: On success, 1 if symbol <var>sym_id</var> is productive, 0 if not.  If the grammar
If <var>sym_id</var> is well-formed, but there is no
such symbol, -1. 
is not precomputed, or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_symbol_is_prediction_event</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID sym_id</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fprediction_005fevent-25"></a></var><br>
&mdash; Function: int <b>marpa_g_symbol_is_prediction_event_set</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID sym_id, int value</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fprediction_005fevent_005fset-26"></a></var><br>
<blockquote>
        <p>Libmarpa can be set up
to generate a
<code>MARPA_EVENT_SYMBOL_PREDICTED</code>
event when a symbol is predicted. 
A symbol is said to be <strong>predicted</strong>
when a it is acceptable at the current
earleme according to the grammar.

        <p>For predicted events to occur, the symbol must be marked
as a predicted event symbol. 
The <code>marpa_g_symbol_is_predicted_event_set()</code> function
marks symbol <var>sym_id</var> as a predicted event symbol
if <var>value</var> is 1,
and unmarks it
it as a predicted event symbol if <var>value</var> is 0. 
The <code>marpa_g_symbol_is_predicted_event()</code> method
returns the current value of the predicted event marking
for symbol <var>sym_id</var>.

        <p>The predicted event marking cannot be changed once
the grammar is precomputed. 
However, if a symbol is marked as a predicted event symbol,
it can be deactivated
and reactivated in the recognizer.

        <p>Success: On success, 1 if symbol <var>sym_id</var>
is a predicted event symbol after the
call, 0 otherwise.

        <p>Failures:
If <var>sym_id</var> is well-formed, but there is no
such symbol, -1. 
if the grammar <var>g</var> is precomputed;
or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_symbol_is_start</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID sym_id</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fstart-27"></a></var><br>
<blockquote>
        <p>This return value of this call indicates whether <var>sym_id</var>
is the start symbol.

        <p>Return value:
On success, 1 if <var>sym_id</var> is the start symbol;
0 otherwise. 
If <var>sym_id</var> is well-formed, but there is no
such symbol, -1. 
On other failure, &minus;2.

        </blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_symbol_is_terminal</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID sym_id</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fterminal-28"></a></var><br>
&mdash; Function: int <b>marpa_g_symbol_is_terminal_set</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID sym_id, int value</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fterminal_005fset-29"></a></var><br>
<blockquote>
        <p>These methods, respectively, set
and query the &ldquo;terminal status&rdquo; of a symbol. 
To be used as an input symbol
in the <code>marpa_r_alternative()</code> method,
a symbol must be a terminal. 
This function flags symbol <var>sym_id</var> as a terminal if
<var>value</var> is 1,
or flags it as a non-terminal if <var>value</var> is 0.

        <p>Once set to a value with the
<code>marpa_g_symbol_is_terminal_set()</code> method,
the terminal status of a symbol is &ldquo;locked&rdquo; at that value. 
A subsequent call to
<code>marpa_g_symbol_is_terminal_set()</code> that attempts
to change the terminal status
of <var>sym_id</var> to a value different from its current one
will fail. 
The error code will be <code>MARPA_ERR_TERMINAL_IS_LOCKED</code>.

        <p>By default, a symbol is a terminal if and only if it
does not appear on the LHS of any rule. 
An attempt to flag a nulling symbol
as a terminal will cause a failure,
but this is not necesssarily detected before precomputation.

        <p>Return value: On success, 1 if symbol <var>sym_id</var>
is a terminal symbol after the
call, 0 otherwise. 
If <var>sym_id</var> is well-formed, but there is no
such symbol, -1. 
If <var>value</var> is not 0 or 1;
if the terminal status is locked and <var>value</var>
is different from its current value;
if the grammar <var>g</var> is precomputed;
or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Symbol_ID <b>marpa_g_symbol_new</b> (<var>Marpa_Grammar g</var>)<var><a name="index-marpa_005fg_005fsymbol_005fnew-30"></a></var><br>
<blockquote>
        <p>Creates a new symbol. 
The symbol ID will be a non-negative integer.

        <p>Return value: On success, the ID of a new symbol;
On failure, &minus;2.

        </blockquote></div>

<p><a name="Rules"></a>

<h3 class="section">11.5 Rules</h3>

<div class="defun">
&mdash; Function: int <b>marpa_g_highest_rule_id</b> (<var>Marpa_Grammar g</var>)<var><a name="index-marpa_005fg_005fhighest_005frule_005fid-31"></a></var><br>
<blockquote><p>Return value: On success, the numerically largest rule ID
of <var>g</var>. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_rule_is_accessible</b> (<var>Marpa_Grammar g, Marpa_Rule_ID rule_id</var>)<var><a name="index-marpa_005fg_005frule_005fis_005faccessible-32"></a></var><br>
<blockquote><p>A rule is <dfn>accessible</dfn> if it can be reached from the start symbol. 
A rule is accessible if and only if its LHS symbol is accessible. 
The start rule is always an accessible rule.

        <p>Return value: On success, 1 if rule <var>rule_id</var>
is accessible, 0 if not. 
If <var>rule_id</var> is well-formed, but there is no
such rule, -1. 
If the grammar
is not precomputed, or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_rule_is_nullable</b> (<var> Marpa_Grammar g, Marpa_Rule_ID ruleid</var>)<var><a name="index-marpa_005fg_005frule_005fis_005fnullable-33"></a></var><br>
<blockquote><p>A rule is <dfn>nullable</dfn> if it sometimes produces the empty string. 
A <strong>nulling</strong> rule is always a <strong>nullable</strong> rule,
but not all <strong>nullable</strong> rules are <strong>nulling</strong> rules.

        <p>Return value: On success,
1 if rule <var>ruleid</var> is nullable, 0 if not. 
If <var>rule_id</var> is well-formed, but there is no
such rule, -1. 
If the grammar is not precomputed, or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_rule_is_nulling</b> (<var>Marpa_Grammar g, Marpa_Rule_ID ruleid</var>)<var><a name="index-marpa_005fg_005frule_005fis_005fnulling-34"></a></var><br>
<blockquote><p>A rule is <dfn>nulling</dfn> if it always produces the empty string.

        <p>Return value: On success,
1 if rule <var>ruleid</var> is nulling, 0 if not. 
If <var>rule_id</var> is well-formed, but there is no
such rule, -1. 
If the grammar is not precomputed, or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_rule_is_loop</b> (<var>Marpa_Grammar g, Marpa_Rule_ID rule_id</var>)<var><a name="index-marpa_005fg_005frule_005fis_005floop-35"></a></var><br>
<blockquote><p>A rule is a loop rule if it non-trivially
produces the string of length one
which consists only of its LHS symbol. 
Such a derivation takes the parse back to where
it started, hence the term &ldquo;loop&rdquo;. 
&ldquo;Non-trivially&rdquo; means the zero-step derivation does not count &mdash; the
derivation must have at least one step.

        <p>The presence of a loop rule makes a grammar infinitely ambiguous,
and applications will typically want to treat them as fatal errors. 
But nothing forces an application to do this,
and Marpa will successfully parse and evaluate grammars with
loop rules.

        <p>Return value: On success,
1 if rule <var>rule_id</var> is a loop rule, 0 if not. 
If <var>rule_id</var> is well-formed, but there is no
such rule, -1. 
If the grammar
is not precomputed, or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_rule_is_productive</b> (<var>Marpa_Grammar g, Marpa_Rule_ID rule_id</var>)<var><a name="index-marpa_005fg_005frule_005fis_005fproductive-36"></a></var><br>
<blockquote><p>A rule is <dfn>productive</dfn> if it can produce a string of terminals. 
An rule is productive if and only if all the symbols on
its RHS are productive. 
The empty string counts as a string of terminals,
so that a nullable rule is always a productive rule. 
For that same reason,
an empty rule is considered productive.

        <p>Return value: On success,
1 if rule <var>rule_id</var> is productive, 0 if not. 
If <var>rule_id</var> is well-formed, but there is no
such rule, -1. 
If the grammar is not precomputed, or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_rule_length</b> (<var> Marpa_Grammar g, Marpa_Rule_ID rule_id</var>)<var><a name="index-marpa_005fg_005frule_005flength-37"></a></var><br>
<blockquote><p>The length of a rule is the number of symbols on its RHS.

        <p>Return value: On success, the length of rule <var>rule_id</var>. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Symbol_ID <b>marpa_g_rule_lhs</b> (<var> Marpa_Grammar g, Marpa_Rule_ID rule_id</var>)<var><a name="index-marpa_005fg_005frule_005flhs-38"></a></var><br>
<blockquote><p>Return value: On success, the LHS symbol of rule <var>rule_id</var>. 
If <var>rule_id</var> is well-formed, but there is no
such rule, -1. 
On other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Rule_ID <b>marpa_g_rule_new</b> (<var>Marpa_Grammar g, Marpa_Symbol_ID lhs_id, Marpa_Symbol_ID *rhs_ids, int length</var>)<var><a name="index-marpa_005fg_005frule_005fnew-39"></a></var><br>
<blockquote><p>Creates a new external BNF rule in grammar <var>g</var>. 
The ID of the new rule will be a non-negative integer,
which will be unique to that rule. 
In addition to BNF rules, Marpa also allows sequence rules,
which are created by another method:
<code>marpa_g_sequence_new()</code>. 
Sequence rules and BNF rules are numbered in the same series,
so that a BNF rule will never have the same rule ID as a sequence
rule, and vice versa.

        <p>The LHS symbol is <var>lhs_id</var>,
and there are <var>length</var> symbols on the RHS. 
The RHS symbols are in an array
pointed to by <var>rhs_ids</var>.

        <p>Possible failures, with their error codes, include:
          <ul>
<li><code>MARPA_ERR_SEQUENCE_LHS_NOT_UNIQUE</code>: The LHS symbol is the same
as that of a sequence rule. 
<li><code>MARPA_ERR_DUPLICATE_RULE</code>: The new rule would duplicate another BNF
rule. 
Another BNF rule is considered the duplicate of the new one,
if its LHS symbol is the same as symbol <var>lhs_id</var>,
if its length is the same as <var>length</var>,
and if its RHS symbols match one for one those
in the array of symbols <var>rhs_ids</var>. 
</ul>

        <p>Return value:  On success, the ID of new external rule. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Symbol_ID <b>marpa_g_rule_rhs</b> (<var> Marpa_Grammar g, Marpa_Rule_ID rule_id, int ix</var>)<var><a name="index-marpa_005fg_005frule_005frhs-40"></a></var><br>
<blockquote><p>Returns the ID of the symbol in position <var>ix</var>
in the RHS of rule <var>rule_id</var>. 
The RHS position, <var>ix</var>, is zero-based.

        <p>Return value: On success,
the ID of the symbol in position <var>ix</var>
on the rules RHS. 
If <var>rule_id</var> is well-formed, but there is no
such rule, -1. 
If <var>ix</var> is greater than or equal to the length of
the rule,
or on other failure, &minus;2. 
</p></blockquote></div>

<p><a name="Sequences"></a>

<h3 class="section">11.6 Sequences</h3>

<div class="defun">
&mdash; Function: int <b>marpa_g_rule_is_proper_separation</b> (<var> Marpa_Grammar g, Marpa_Rule_ID rule_id</var>)<var><a name="index-marpa_005fg_005frule_005fis_005fproper_005fseparation-41"></a></var><br>
<blockquote>
        <p>Return value:
On success, if rule <var>rule_id</var> is not a sequence rule, 0. 
On success, if rule <var>rule_id</var>
is a sequence rule where the proper separation flag
is set, 1. 
On success, if rule <var>rule_id</var>
is a sequence rule where the proper separation flag
is <strong>not</strong> set, 0. 
If <var>rule_id</var> is well-formed, but there is no
such rule, -1. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_sequence_min</b> (<var> Marpa_Grammar g, Marpa_Rule_ID rule_id</var>)<var><a name="index-marpa_005fg_005fsequence_005fmin-42"></a></var><br>
<blockquote>
        <p>Returns the mininum length of a sequence rule. 
This accessor can be also be used to test whether
or not a rule is a sequence rule. 
&minus;1 is returned if and only if the rule is valid
but not a sequence rule.

        <p>Return value:
If rule <var>rule_id</var> is a sequence rule, its minimum length. 
If rule <var>rule_id</var> is valid, but is
not the rule ID of sequence rule, &minus;1. 
If <var>rule_id</var> is well-formed, but there is no
such rule,
or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Rule_ID <b>marpa_g_sequence_new</b> (<var>Marpa_Grammar g, Marpa_Symbol_ID lhs_id, Marpa_Symbol_ID rhs_id, Marpa_Symbol_ID separator_id, int min, int flags </var>)<var><a name="index-marpa_005fg_005fsequence_005fnew-43"></a></var><br>
<blockquote><p>Adds a new sequence rule to grammar <var>g</var>. 
The ID of the new sequence rule will be a non-negative integer,
which is unique to that rule. 
Sequence rules and BNF rules are numbered in the same series,
so that a BNF rule will never have the same rule ID as a sequence
rule, and vice versa.

        <p>The sequence is <var>lhs_id</var>,
and the item to be repeated in the sequence is <var>rhs_id</var>. 
The sequence must be repeated at least <var>min</var> times,
where <var>min</var> is 0 or 1. 
If <var>separator_id</var> is non-negative,
it is a separator symbol.

        <p>If <code>flags &amp; MARPA_PROPER_SEPARATION</code> is non-zero,
separation is &ldquo;proper&rdquo;, that is,
a trailing separator is not allowed. 
The term <dfn>proper</dfn> is based on the idea that
properly-speaking, separators should actually separate items.

        <p>Some higher-level Marpa interfaces offer the ability to
discard separators in the semantics,
and in fact will do this by default. 
At the Libmarpa level, sequences always &ldquo;keep
separators&rdquo;. 
It is up to the programmer to arrange
to discard separators,
if that is what is desired.

        <p>The sequence RHS, or item,
is restricted to a single symbol,
and that symbol cannot be nullable. 
If <var>separator_id</var> is a symbol, it also cannot
be a nullable symbol. 
Nullables on the RHS of sequences are restricted
because they lead to highly ambiguous grammars. 
Grammars of this kind are allowed by Libmarpa, but
they must be expressed using BNF rules, not sequence rules. 
This is for two reasons:
First, sequence optimizations would not work
in the presence of nullables. 
Second, since it is not completely clear what
an application intends
when it asks for a sequence of identical items,
some of which are nullable,
the user's intent can be more clearly expressed
directly in BNF.

        <p>The LHS symbol cannot be the LHS of any other rule,
whether a BNF rule or a sequence rule. 
On an attempt to create an sequence rule with a duplicate
LHS,
<code>marpa_g_sequence_new()</code> fails,
setting the error code to
<code>MARPA_ERR_SEQUENCE_LHS_NOT_UNIQUE</code>.

        <p>Sequence rules do not add to the classes of grammar parsed
by Libmarpa &mdash;
a sequence can always be written as BNF rules. 
When a rule is created
with the <code>marpa_g_sequence_new()</code> method,
Libmarpa will understand that it is a sequence,
and will optimize accordingly. 
The speedup is often considerable.

        <p>Return value:  On success, the ID of the external rule. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_sequence_separator</b> (<var> Marpa_Grammar g, Marpa_Rule_ID rule_id</var>)<var><a name="index-marpa_005fg_005fsequence_005fseparator-44"></a></var><br>
<blockquote>
        <p>Return value:
If rule <var>rule_id</var> is a sequence rule, its separator. 
If rule <var>rule_id</var> is a sequence rule,, but there is no
separator, &minus;1. 
If <var>rule_id</var> is
not a sequence rule,
does not exist
or is not well-formed;
or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_symbol_is_counted</b> (<var>Marpa_Grammar g, Marpa_Symbol_ID sym_id</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fcounted-45"></a></var><br>
<blockquote><p>A symbol is <dfn>counted</dfn>
if it appears on the RHS of a sequence rule,
or if it is used as
the separator symbol of a sequence rule.

        <p>Return value: On success,
1 if symbol <var>sym_id</var> is counted, 0 if not. 
On failure, &minus;2. 
</p></blockquote></div>

<p><a name="Ranks"></a>

<h3 class="section">11.7 Ranks</h3>

<div class="defun">
&mdash; Function: Marpa_Rank <b>marpa_g_rule_rank</b> (<var> Marpa_Grammar g, Marpa_Rule_ID rule_id</var>)<var><a name="index-marpa_005fg_005frule_005frank-46"></a></var><br>
&mdash; Function: Marpa_Rank <b>marpa_g_rule_rank_set</b> (<var> Marpa_Grammar g, Marpa_Rule_ID rule_id, Marpa_Rank rank</var>)<var><a name="index-marpa_005fg_005frule_005frank_005fset-47"></a></var><br>
<blockquote>
        <p>These methods, respectively, set
and query the rank of a rule <var>rule_id</var>. 
When <var>rule_id</var> is created, its rank
initialized to the default rank of the grammar.

        <p>Initially, the default rank of the grammar is 0. 
Methods to reset the grammar's default rank
are currently in the experimental stage.

        <p>Return value: On success, returns
the rank <strong>after</strong>
the call,
and sets the error code to
<code>MARPA_ERR_NONE</code>. 
On failure, returns &minus;2,
and sets the error code to an appropriate
value, which will never be
<code>MARPA_ERR_NONE</code>. 
Note that when the rank is &minus;2,
the error code is the only way to distinguish
success from failure. 
The error code can be determined by using the
<code>marpa_g_error()</code> call.

     </blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_rule_null_high</b> (<var> Marpa_Grammar g, Marpa_Rule_ID rule_id</var>)<var><a name="index-marpa_005fg_005frule_005fnull_005fhigh-48"></a></var><br>
&mdash; Function: int <b>marpa_g_rule_null_high_set</b> (<var> Marpa_Grammar g, Marpa_Rule_ID rule_id, int flag</var>)<var><a name="index-marpa_005fg_005frule_005fnull_005fhigh_005fset-49"></a></var><br>
<blockquote>
        <p>These methods, respectively, set
and discover the &ldquo;null ranks high&rdquo; setting of the rule <var>rule_id</var>. 
The &ldquo;null ranks high&rdquo; setting is either 0 or 1. 
When <var>rule_id</var> is created, its &ldquo;null ranks high&rdquo;
setting is initialized to 0.

        <p>The &ldquo;null ranks high&rdquo; setting affects the ranking of rules
with properly nullable symbols on their right hand side. 
If a rule has properly nullable symbols on its RHS,
each instance in which it appears in a parse will have a pattern
of nulled and non-nulled symbols. 
Such a pattern is called a &ldquo;null variant&rdquo;.

        <p>If the &ldquo;null ranks high&rdquo; setting is 0 (the default),
nulled symbols rank low. 
If the &ldquo;null ranks high&rdquo; setting is 1,
nulled symbols rank high. 
Ranking of a null variants is done from left-to-right.

        <p>Return value: On success, the setting
of the &ldquo;null ranks high&rdquo; flag <strong>after</strong>
the call. 
If the grammar has been precomputed,
or on other failure, &minus;2.

        </blockquote></div>

<p><a name="Grammar-precomputation"></a>

<h3 class="section">11.8 Precomputing the Grammar</h3>

<div class="defun">
&mdash; Function: int <b>marpa_g_precompute</b> (<var>Marpa_Grammar g</var>)<var><a name="index-marpa_005fg_005fprecompute-50"></a></var><br>
<blockquote>
        <p><a name="marpa_005fg_005fprecompute"></a>Precomputation is necessary for a recognizer to be generated
from a grammar. 
On success, <code>marpa_g_precompute</code> returns a non-negative
number to indicate that it precomputed the grammar without
issues. 
On failure, <code>marpa_g_precompute</code> returns &minus;2.

        <p>Precomputation may return one or more events,
which may be queried using the
<code>marpa_g_event()</code> method. 
At this point events only occur when failure is reported,
and events always report issues. 
But application writers should expect future versions
to have events which are reported on success,
as well as events which do not represent issues.

        <p>A <code>MARPA_EVENT_LOOP_RULES</code> event occurs
when there are infinite loop rules (cycles)
in the grammar. 
The presence of one or more of these will cause failure
to be reported,
but will not prevent the grammar from being precomputed.

        <p>Each <code>MARPA_EVENT_COUNTED_NULLABLE</code> event is a symbol
which is a nullable on the right hand side of a sequence
rule &mdash; a &ldquo;counted&rdquo; symbol. 
The presence of one or more of these will cause failure
to be reported,
and will prevent the grammar from being precomputed. 
So that the programmer can fix several at once,
these failures are delayed until events are created
for all of the counted nullables.

        <p>Each <code>MARPA_EVENT_NULLING_TERMINAL</code> event is a nulling
symbol which is also flagged as a terminal. 
Since terminals cannot be of zero length, this is a logical
impossibility. 
The presence of one or more of these will cause failure
to be reported,
and will prevent the grammar from being precomputed. 
So that the programmer can fix several at once,
the failure is delayed until events are created
for all of the counted nullables.

        <p>Precomputation involves freezing
and then thoroughly checking the grammar. 
Among the reasons for precomputation to fail
are the following:

          <ul>
<li><code>MARPA_ERR_NO_RULES</code>: The grammar has no rules. 
<li><code>MARPA_ERR_NO_START_SYMBOL</code>: No start symbol was specified. 
<li><code>MARPA_ERR_INVALID_START_SYMBOL</code>: A start symbol ID was specified, but it
is not the ID of a valid symbol. 
<li><code>MARPA_ERR_START_NOT_LHS</code>: The start symbol is not on the LHS of any rule. 
<li><code>MARPA_ERR_UNPRODUCTIVE_START</code>: The start symbol is not productive. 
<li><code>MARPA_ERR_COUNTED_NULLABLE</code>: A symbol on the RHS of a sequence rule is
nullable. 
Libmarpa does not allow this. 
<li><code>MARPA_ERR_NULLING_TERMINAL</code>: A terminal is also a nulling symbol. 
Libmarpa does not allow this. 
</ul>

        <p>More details of these can be found under the
description of the appropriate code. 
See <a href="#External-error-codes">External error codes</a>.

        <p><code>marpa_g_precompute()</code> is unusual in that it
is possible to treat one of its failures as &ldquo;advisory&rdquo;,
and to proceed with parsing. 
If
<code>marpa_g_precompute()</code> fails with an error code
of <code>MARPA_ERR_GRAMMAR_HAS_CYCLE</code>,
parsing can proceed, just as it typically would for
success. 
The grammar will have been precomputed, as
calling the <code>marpa_g_is_precomputed()</code> method
will confirm.

        <p>Most applications, however,
will want to simply treat failure
with <code>MARPA_ERR_GRAMMAR_HAS_CYCLE</code>,
as simply another failure,
and fix the cycles before parsing. 
Cycles make a grammar infinitely ambiguous,
and are considered useless in current
practice. 
Cycles make processing the grammar less
efficient, sometimes considerably so. 
Detection of cycles is returned as failure
because that is by far the convenient thing to do
for the vast majority of applications.

        <p>Return value: On success, a non-negative number. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_is_precomputed</b> (<var>Marpa_Grammar g</var>)<var><a name="index-marpa_005fg_005fis_005fprecomputed-51"></a></var><br>
<blockquote><p>Return value: On success, 1
if grammar <var>g</var> is already precomputed,
0 otherwise. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_has_cycle</b> (<var>Marpa_Grammar g</var>)<var><a name="index-marpa_005fg_005fhas_005fcycle-52"></a></var><br>
<blockquote><p>This function allows the application to determine if grammar
<var>g</var> has a cycle. 
As mentioned, most applications will want to treat these
as fatal errors. 
To determine which rules are in the cycle,
<code>marpa_g_rule_is_loop()</code> can be used.

        <p>Return value: On success, 1 if the grammar has a cycle,
0 otherwise. 
On failure, &minus;2. 
</p></blockquote></div>

<p><a name="Recognizer-methods"></a>

<h2 class="chapter">12 Recognizer methods</h2>

<p><a name="Recognizer-overview"></a>

<h3 class="section">12.1 Overview</h3>

<p>An archtypal application uses a recognizer to read input. 
To create a recognizer, use the <code>marpa_r_new()</code> method. 
When a recognizer is no longer in use, its memory can be freed
using the
<code>marpa_r_unref()</code> method.

   <p>To make a recognizer ready for input,
use the <code>marpa_r_start_input()</code> method.

   <p>The recognizer starts with its current earleme
at location 0. 
To read a token at the current earleme,
use the <code>marpa_r_alternative()</code> call.

   <p>To complete the processing of the current earleme,
and move forward to a new one,
use the <code>marpa_r_earleme_complete()</code> call.

<p><a name="Recognizer-constructor"></a>

<h3 class="section">12.2 Creating a new recognizer</h3>

<div class="defun">
&mdash; Function: Marpa_Recognizer <b>marpa_r_new</b> (<var> Marpa_Grammar g </var>)<var><a name="index-marpa_005fr_005fnew-53"></a></var><br>
<blockquote><p>Creates a new recognizer. 
The reference count of the recognizer will be 1. 
The reference count of <var>g</var>,
the base grammar,
will be incremented by one.

        <p>Return value:  On success, the newly created recognizer. 
If <var>g</var> is not precomputed, or on other failure, <code>NULL</code>. 
</p></blockquote></div>

<p><a name="Recognizer-reference-counting"></a>

<h3 class="section">12.3 Keeping the reference count of a recognizer</h3>

<div class="defun">
&mdash; Function: Marpa_Recognizer <b>marpa_r_ref</b> (<var>Marpa_Recognizer r</var>)<var><a name="index-marpa_005fr_005fref-54"></a></var><br>
<blockquote><p>Increases the reference count by 1. 
Not needed by most applications.

        <p>Return value:
On success, the recognizer object, <var>r</var>. 
On failure, <code>NULL</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>marpa_r_unref</b> (<var>Marpa_Recognizer r</var>)<var><a name="index-marpa_005fr_005funref-55"></a></var><br>
<blockquote><p>Decreases the reference count by 1,
destroying <var>r</var> once the reference count reaches
zero. 
When <var>r</var> is destroyed, the reference count
of its base grammar is decreased by one. 
If this takes the reference count of the base grammar
to zero, it too is destroyed.

        </blockquote></div>

<p><a name="Recognizer-life-cycle-mutators"></a>

<h3 class="section">12.4 Life cycle mutators</h3>

<div class="defun">
&mdash; Function: int <b>marpa_r_start_input</b> (<var>Marpa_Recognizer r</var>)<var><a name="index-marpa_005fr_005fstart_005finput-56"></a></var><br>
<blockquote><p>Makes <var>r</var> ready to accept input. 
The first Earley set,
the one at earleme 0,
will be completed during this call.

        <p>Because the call to <code>marpa_r_start_input()</code>
completes an Earley set,
it may generate events. 
For details about
the events that may be generated during
Earley set completion,
see the description of the
<code>marpa_r_earleme_complete()</code> method.

        <p>Return value:  On success, a non-negative value. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_alternative</b> (<var>Marpa_Recognizer r, Marpa_Symbol_ID token_id, int value, int length</var>)<var><a name="index-marpa_005fr_005falternative-57"></a></var><br>
<blockquote><p>Reads a token into <var>r</var>. 
The token will start at the current earleme. 
Libmarpa allows tokens to be ambiguous, to be of
variable length and to overlap. 
<var>token_id</var> is the symbol ID of the token,
which must be a terminal. 
<var>length</var> is the length of the token.

        <p><var>value</var> is an
integer that represents the value of the
token. 
In applications where the token's actual value is not an integer, it is
expected that the application will use this value as
a &ldquo;virtual&rdquo; value,
perhaps finding the actual value by using <var>value</var>
to index an array. 
<var>value</var> is not used inside Libmarpa &mdash; it is simply
stored to be returned by the valuator
as a convenience for the application. 
Some applications may prefer to track token values on
their own, perhaps based on
the earleme location and <var>token_id</var>,
instead of using Libmarpa's token values.

        <p>A <var>value</var> of 0 is reserved for a now-deprecated feature. 
Do not use it. 
For more details on that feature, see the
section <a href="#Valued-and-unvalued-symbols">Valued and unvalued symbols</a>.

        <p>When <code>marpa_r_alternative()</code>
is successful,
the value of the furthest earleme is set to
the greater of its value before the call,
and <var>current</var>+<var>length</var>,
where <var>current</var> is the value of the current earleme. 
The values of the current and latest earlemes
are unchanged by
calls to <code>marpa_r_alternative()</code>.

        <p>Several error codes leave the recognizer in a fully
recoverable state, allowing the application to
retry the <code>marpa_r_alternative()</code> method. 
Retry is efficient, and quite useable as a parsing
technique. 
The error code
of primary interest from this point of view
is <code>MARPA_ERR_UNEXPECTED_TOKEN_ID</code>,
which indicates that the token was not accepted
because of its token ID. 
Retry after this condition is used in several
applications,
and is called &ldquo;the Ruby Slippers technique&rdquo;.

        <p>The error codes
<code>MARPA_ERR_DUPLICATE_TOKEN</code>,
<code>MARPA_ERR_NO_TOKEN_EXPECTED_HERE</code>
and <code>MARPA_ERR_INACCESSIBLE_TOKEN</code>
also leave the recognizer in a fully recoverable
state, and may also be useable for the
Ruby Slippers or similar techniques. 
At this writing,
the author knows of no applications which
attempt to recover from these errors.

        <p>Return value:  On success, <code>MARPA_ERR_NONE</code>. 
On failure, some other error code.

        </blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Earleme <b>marpa_r_earleme_complete</b> (<var>Marpa_Recognizer r</var>)<var><a name="index-marpa_005fr_005fearleme_005fcomplete-58"></a></var><br>
<blockquote><p>This method does the final processing for the current earleme. 
It then advances the current earleme by one. 
Note that <code>marpa_r_earleme_complete()</code> may be called
even when no tokens have been read at the current earleme &mdash;
in the character-per-earleme input model, for example, tokens
can span many characters and, if the input is unambiguous over that
span, there will be no other tokens that start inside it.

        <p>As mentioned,
<code>marpa_r_earleme_complete()</code> always advances the current earleme,
incrementing its value by 1. 
This means that value of the current earleme after the call
will be the one plus the value of the earleme processed by the call
to <code>marpa_r_earleme_complete()</code>. 
If any token was accepted at the earleme being processed,
<code>marpa_r_earleme_complete()</code> creates a new Earley set
which will be the latest Earley set
and, after the call, the latest
earleme will be equal to the new current earleme. 
If no token was accepted at the
earleme being processed,
no Earley set is created,
and the value of the latest earleme remains unchanged. 
The value of the furthest earleme is never changed by
a call to <code>marpa_r_earleme_complete()</code>.

        <p>During this method, one or more events may occur. 
On success, this function returns the number of events
generated,
but it is important to note that events may be
created whether earleme completion fails or succeeds. 
When this method fails,
the application must call <code>marpa_g_event()</code>
if it wants to determine if any events occurred. 
Since the reason for failure to complete an earleme is often
detailed in the events, applications that fail will often
be at least as interested in the events as those
that succeed.

        <p>The <code>MARPA_EVENT_EARLEY_ITEM_THRESHOLD</code> event
indicates that an application-settable threshold
on the number of Earley items has been reached or exceeded. 
What this means depends on the application,
but when the default threshold is exceeded,
it means that it is very likely
that the time and space resources consumed by
the parse will prove excessive.

        <p>A parse is &ldquo;exhausted&rdquo; when it can accept no more
input. 
This can happen both on success and on failure. 
Note that the failure due to parse exhaustion
only means failure
at the current earleme. 
There may be successful parses
at earlier earlemes.

        <p>If a parse is exhausted, but successful,
an event with the event code
<code>MARPA_EVENT_EXHAUSTED</code> occurs. 
Because the parse is exhausted,
no input will be accepted at later earlemes. 
It is quite common for a parse to become exhausted
when it succeeds. 
Many practical grammars are designed so that a
successful parse cannot be extended.

        <p>An exhausted parse may cause a failure,
in which case
<code>marpa_r_earleme_complete()</code> returns an
error
whose error code is <code>MARPA_ERR_PARSE_EXHAUSTED</code>. 
For a parse to fail at an earleme due to exhaustion,
it must be the case that no alternatives were
accepted at that earleme. 
In fact,
in the standard input model,
a failure due to parse exhaustion
occurs if and only if
no alternatives
were accepted at the current earleme.

        <p>The circumstances under which
failure due to parse exhaustion occurs
are slightly more complicated
when variable length tokens are in use. 
Informally,
a parse will never fail due to exhaustion as long
as it is possible that a token
ending at some future
earleme will continue the parse. 
More precisely,
a call to
<code>marpa_r_earleme_complete()</code> fails
due to parse exhaustion
if and only if, first,
no alternatives were added at the current earleme
and, second,
that call left the current
earleme equal to the furthest earleme.

        <p>Return value:  On success, the number of events generated. 
On failure, &minus;2. 
</p></blockquote></div>

<p><a name="Location-accessors"></a>

<h3 class="section">12.5 Location accessors</h3>

<div class="defun">
&mdash; Function: <code>unsigned int</code> <b>marpa_r_current_earleme</b> (<var>Marpa_Recognizer r</var>)<var><a name="index-marpa_005fr_005fcurrent_005fearleme-59"></a></var><br>
<blockquote><p>Return value: If input has started, the current earleme. 
If input has not started, &minus;1. 
Always succeeds. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Earleme <b>marpa_r_earleme</b> (<var> Marpa_Recognizer r, Marpa_Earley_Set_ID set_id</var>)<var><a name="index-marpa_005fr_005fearleme-60"></a></var><br>
<blockquote>
        <p>In the default, token-stream model, Earley set ID and earleme
are always equal, but this is not the case in other input
models. 
(The ID of an Earley set ID is also called its ordinal.) 
If there is no Earley set whose ID is
<var>set_id</var>,
<code>marpa_r_earleme()</code> fails. 
If <var>set_id</var> was negative,
the error code is set to
<code>MARPA_ERR_INVALID_LOCATION</code>. 
If <var>set_id</var> is greater than the ordinal
of the latest Earley set,
the error code is set to
<code>MARPA_ERR_NO_EARLEY_SET_AT_LOCATION</code>.

        <p>At this writing, there is no method for
the inverse operation (conversion of an earleme to an Earley set
ID). 
One consideration in writing
such a method is that not all earlemes correspond to Earley sets. 
Applications that want to map earlemes
to Earley sets will have no trouble if they
are using the standard input model &mdash;
the Earley set
ID is always exactly equal to the earleme in that model. 
For other applications
that want an earleme-to-ID mapping,
the most general method is create an ID-to-earleme
array using the <code>marpa_r_earleme()</code> method
and invert it.

        <p>Return value:
On success,
the earleme corresponding to Earley
set <var>set_id</var>. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_earley_set_value</b> (<var> Marpa_Recognizer r, Marpa_Earley_Set_ID earley_set</var>)<var><a name="index-marpa_005fr_005fearley_005fset_005fvalue-61"></a></var><br>
<blockquote><p>Returns the integer value of <var>earley_set</var>. 
For more details, see
the description of <code>marpa_r_earley_set_values()</code>.

        <p>Return value: On success, the value of <var>earley_set</var>. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_earley_set_values</b> (<var> Marpa_Recognizer r, Marpa_Earley_Set_ID earley_set, int* p_value, void** p_pvalue </var>)<var><a name="index-marpa_005fr_005fearley_005fset_005fvalues-62"></a></var><br>
<blockquote><p>If <var>p_value</var> is non-zero,
sets the location pointed to by
<var>p_value</var> to the integer value of the Earley set. 
Similarly, if <var>p_pvalue</var> is non-zero,
sets the location pointed to by
<var>p_pvalue</var> to the pointer value of the Earley set.

        <p>The &ldquo;value&rdquo; and &ldquo;pointer&rdquo; of an Earley set are
an arbitrary integer
and an arbitrary pointer
that the application
can use for its own purposes. 
In character-per-earleme input models, for example,
the integer can be the codepoint of the current character. 
In a traditional token-per-earley input model,
they could be used to indicate the string value of the token &ndash;
the pointer could point to the start of the string,
and the integer could indicate its length.

        <p>The Earley set value and pointer can be set using
the
<code>marpa_r_latest_earley_set_values_set()</code> method. 
The Earley set integer value defaults to &minus;1,
and the pointer value defaults to <code>NULL</code>.

        <p>Return value: On success, returns a non-negative integer. 
On failure, returns &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <code>unsigned int</code> <b>marpa_r_furthest_earleme</b> (<var>Marpa_Recognizer r</var>)<var><a name="index-marpa_005fr_005ffurthest_005fearleme-63"></a></var><br>
<blockquote><p>Return value: On success, the furthest earleme. 
Always succeeds. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Earley_Set_ID <b>marpa_r_latest_earley_set</b> (<var>Marpa_Recognizer r</var>)<var><a name="index-marpa_005fr_005flatest_005fearley_005fset-64"></a></var><br>
<blockquote><p>This method returns the Earley set ID (ordinal) of the latest Earley set. 
Applications that want the
value of the latest earleme can convert
this value using
the <code>marpa_r_earleme()</code> method.

        <p>Return value: On success, the ID of the latest Earley set. 
Always succeeds. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_latest_earley_set_value_set</b> (<var> Marpa_Recognizer r, int value</var>)<var><a name="index-marpa_005fr_005flatest_005fearley_005fset_005fvalue_005fset-65"></a></var><br>
<blockquote><p>Sets the integer value of the latest Earley set. 
For more details, see
the description of
<code>marpa_r_latest_earley_set_values_set()</code>.

        <p>Return value: On success, the new value of <var>earley_set</var>. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_latest_earley_set_values_set</b> (<var> Marpa_Recognizer r, int value, void* pvalue</var>)<var><a name="index-marpa_005fr_005flatest_005fearley_005fset_005fvalues_005fset-66"></a></var><br>
<blockquote><p>Sets the integer and pointer value of the latest Earley set. 
For more about the &ldquo;integer value&rdquo; and &ldquo;pointer value&rdquo;
of an Earley set,
see the description of the
<code>marpa_r_earley_set_values()</code> method.

        <p>Return value: On success, returns a non-negative integer. 
On failure, returns &minus;2. 
</p></blockquote></div>

<p><a name="Other-parse-status-methods"></a>

<h3 class="section">12.6 Other parse status methods</h3>

<div class="defun">
&mdash; Function: int <b>marpa_r_completion_symbol_activate</b> (<var> Marpa_Recognizer r, Marpa_Symbol_ID sym_id, int reactivate </var>)<var><a name="index-marpa_005fr_005fcompletion_005fsymbol_005factivate-67"></a></var><br>
<blockquote>
        <p>Allows the user to deactivate and reactivate symbol completion
events in the recognizer. 
If <var>reactivate</var> is zero, the event is deactivated. 
If <var>reactivate</var> is one, the event is activated.

        <p>Symbol completion events are active by default if
the symbol was set up for completion events in the
grammar. 
If a symbol was not set up for completion events in
the grammar, symbol completion events are inactive
by default and any attempt to change that is a fatal error.

        <p>Success cases:
On success,
the method returns the value of <var>reactivate</var>. 
The method succeeds trivially
if the symbol is already set as indicated by
<var>reactivate</var>.

        <p>Failure cases:
If the active status
of the
completion event for <var>sym_id</var>
cannot be set as indicated by <var>reactivate</var>,
the method fails. 
On failure, &minus;2 is returned. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_earley_item_warning_threshold</b> (<var>Marpa_Recognizer r</var>)<var><a name="index-marpa_005fr_005fearley_005fitem_005fwarning_005fthreshold-68"></a></var><br>
&mdash; Function: int <b>marpa_r_earley_item_warning_threshold_set</b> (<var>Marpa_Recognizer r, int threshold</var>)<var><a name="index-marpa_005fr_005fearley_005fitem_005fwarning_005fthreshold_005fset-69"></a></var><br>
<blockquote><p>These methods, respectively, report and set the Earley item warning threshold. 
The <dfn>Earley item warning threshold</dfn>
is a number that is compared with
the count of Earley items in each Earley set. 
When it is matched or exceeded,
a <code>MARPA_EVENT_EARLEY_ITEM_THRESHOLD</code> event is created.

        <p>If <var>threshold</var> is zero or less,
an unlimited number of Earley items
will be allowed without warning. 
This will rarely be what the user wants.

        <p>By default, Libmarpa calculates a value based on the grammar. 
The formula Libmarpa uses is the result of some experience,
and most applications will
be happy with it.

        <p>Return value:
The value that the Earley item warning threshold has
after the method call is finished. 
Always succeeds. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_expected_symbol_event_set</b> (<var> Marpa_Recognizer r, Marpa_Symbol_ID symbol_id, int value</var>)<var><a name="index-marpa_005fr_005fexpected_005fsymbol_005fevent_005fset-70"></a></var><br>
<blockquote><p>Sets the &ldquo;expected symbol event bit&rdquo; for <var>symbol_id</var> to <var>value</var>. 
A recognizer event is created whenever
symbol <var>symbol_id</var> is expected at the current earleme. 
if and only if the expected symbol event bit
for <var>symbol_id</var> is 1. 
The &ldquo;expected symbol event bit&rdquo; must be 1 or 0.

        <p>In this context, &ldquo;expected&rdquo; means &ldquo;expected as a terminal&rdquo;. 
Even if a symbol is predicted at the current earleme,
if it is not acceptable as a terminal,
it does not trigger an
&ldquo;expected symbol event&rdquo;.

        <p>By default, the &ldquo;expected symbol event bit&rdquo; is 0. 
It is an error to attempt to set the
&ldquo;expected symbol event bit&rdquo; to 1 for a nulling symbol,
an inaccessible symbol,
or an unproductive symbol.

        <p>Return value:
The value of the event bit after the method call is finished. 
-2 if <var>symbol_id</var> is not the ID of a valid symbol;
if it is the ID of an nulling, inaccessible for unproductive symbol;
or on other failure. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_is_exhausted</b> (<var>Marpa_Recognizer r</var>)<var><a name="index-marpa_005fr_005fis_005fexhausted-71"></a></var><br>
<blockquote><p>A parser is &ldquo;exhausted&rdquo; if it cannot accept any more input. 
Both successful and failed parses can be exhausted. 
In many grammars,
the parse is always exhausted as soon as it succeeds. 
Good parses may also exist at earlemes prior to the
current one.

        <p>Return value:
1 if the parser is exhausted, 0 otherwise. 
Always succeeds. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_nulled_symbol_activate</b> (<var> Marpa_Recognizer r, Marpa_Symbol_ID sym_id, int boolean </var>)<var><a name="index-marpa_005fr_005fnulled_005fsymbol_005factivate-72"></a></var><br>
<blockquote>
        <p>Allows the user to deactivate and reactivate symbol nulled
events in the recognizer. 
If <var>boolean</var> is zero, the event is deactivated. 
If <var>boolean</var> is one, the event is activated.

        <p>Symbol nulled events are active by default if
the symbol was set up for nulled events in the
grammar. 
If a symbol was not set up for nulled events in
the grammar, symbol nulled events are inactive
by default and any attempt to change that is a fatal error.

        <p>Success cases:
On success,
the method returns the value of <var>boolean</var>. 
The method succeeds trivially
if the symbol is already set as indicated by
<var>boolean</var>.

        <p>Failure cases:
If the active status
of the
nulled event for <var>sym_id</var>
cannot be set as indicated by <var>boolean</var>,
the method fails. 
On failure, &minus;2 is returned. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_prediction_symbol_activate</b> (<var> Marpa_Recognizer r, Marpa_Symbol_ID sym_id, int boolean </var>)<var><a name="index-marpa_005fr_005fprediction_005fsymbol_005factivate-73"></a></var><br>
<blockquote>
        <p>Allows the user to deactivate and reactivate symbol prediction
events in the recognizer. 
If <var>boolean</var> is zero, the event is deactivated. 
If <var>boolean</var> is one, the event is activated.

        <p>Symbol prediction events are active by default if
the symbol was set up for prediction events in the
grammar. 
If a symbol was not set up for prediction events in
the grammar, symbol prediction events are inactive
by default and any attempt to change that is a fatal error.

        <p>Success cases:
On success,
the method returns the value of <var>boolean</var>. 
The method succeeds trivially
if the symbol is already set as indicated by
<var>boolean</var>.

        <p>Failure cases:
If the active status
of the
prediction event for <var>sym_id</var>
cannot be set as indicated by <var>boolean</var>,
the method fails. 
On failure, &minus;2 is returned. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_terminals_expected</b> (<var> Marpa_Recognizer r, Marpa_Symbol_ID* buffer</var>)<var><a name="index-marpa_005fr_005fterminals_005fexpected-74"></a></var><br>
<blockquote><p>Returns a list of the ID's of the symbols
that are acceptable as tokens
at the current earleme. 
<var>buffer</var> is expected to be large enough to hold
the result. 
This is guaranteed to be the case if the buffer
is large enough to hold a number of
<code>Marpa_Symbol_ID</code>'s that
is greater than or equal to the number of symbols
in the grammar.

        <p>Return value:  On success, the number of <code>Marpa_Symbol_ID</code>'s
in <var>buffer</var>. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_terminal_is_expected</b> (<var> Marpa_Recognizer r, Marpa_Symbol_ID symbol_id</var>)<var><a name="index-marpa_005fr_005fterminal_005fis_005fexpected-75"></a></var><br>
<blockquote>
        <p>Return values on success:
If <var>symbol_id</var> is the
ID of a valid terminal symbol that is expected at
the current earleme,
a number greater than zero. 
If <var>symbol_id</var> is the
ID of a valid terminal symbol that is
<strong>not</strong> expected at
the current earleme, or
if <var>symbol_id</var> is the ID of a valid symbol
that is not a terminal, zero.

        <p>Failure cases:
Returns &minus;2 on failure. 
It is a failure
if <var>symbol_id</var> is not the ID of a valid
symbol. 
</p></blockquote></div>

<p><a name="Progress-reports"></a>

<h2 class="chapter">13 Progress reports</h2>

<p>An important advantage of the Marpa algorithm is the ability
to easily get full information about the state of the parse.

   <p>To start a progress report,
use the <code>marpa_r_progress_report_start()</code> command. 
Only one progress report can be in use at any one time.

   <p>To get the information in a progress report,
it is necessary to step through the progress report
items. 
To get the data for the current progress report item,
and advance to the next one,
use the <code>marpa_r_progress_item()</code> method.

   <p>To destroy a progress report,
freeing the memory it uses,
call the <code>marpa_r_progress_report_finish()</code> method.

<div class="defun">
&mdash; Function: int <b>marpa_r_progress_report_reset</b> (<var> Marpa_Recognizer r</var>)<var><a name="index-marpa_005fr_005fprogress_005freport_005freset-76"></a></var><br>
<blockquote><p>Resets the progress report. 
Assumes a report of the progress has already been initialized
at some Earley set
for recognizer <var>r</var>,
with
<code>marpa_r_progress_report_start()</code>. 
The reset progress report will
be positioned before its first item.

        <p>Return value: On success, a non-negative value. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_progress_report_start</b> (<var> Marpa_Recognizer r, Marpa_Earley_Set_ID set_id</var>)<var><a name="index-marpa_005fr_005fprogress_005freport_005fstart-77"></a></var><br>
<blockquote><p>Initializes a report of the progress at Earley set <var>set_id</var>
for recognizer <var>r</var>. 
If a progress report already exists, it is destroyed and its
memory is freed. 
Initially,
the progress report is positioned before its first item.

        <p>If no Earley set with ID
<var>set_id</var> exists,
<code>marpa_r_progress_report_start()</code> fails. 
The error code is <code>MARPA_ERR_INVALID_LOCATION</code> if <var>set_id</var>
is negative. 
The error code is <code>MARPA_ERR_NO_EARLEY_SET_AT_LOCATION</code>
if <var>set_id</var> is greater than the ID of
the latest Earley set.

        <p>Return value: On success, the number of report items available. 
If the recognizer has not been started;
if <var>set_id</var> does not exist;
or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_progress_report_finish</b> (<var> Marpa_Recognizer r </var>)<var><a name="index-marpa_005fr_005fprogress_005freport_005ffinish-78"></a></var><br>
<blockquote><p>Destroys the report of the progress at Earley set <var>set_id</var>
for recognizer <var>r</var>,
freeing the memory and other resources. 
It is often not necessary to call this method. 
Any previously existing progress report
is destroyed automatically
whenever a new progress report is started,
and when the recognizer is destroyed.

        <p>Return value: &minus;2 if no progress report has been started,
or on other failure. 
On success, a non-negative value. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Rule_ID <b>marpa_r_progress_item</b> (<var> Marpa_Recognizer r, int* position, Marpa_Earley_Set_ID* origin </var>)<var><a name="index-marpa_005fr_005fprogress_005fitem-79"></a></var><br>
<blockquote><p>This method allows access to the data
for the next item of a
progress report. 
If there are no more progress report items,
it returns &minus;1 as a termination indicator
and sets the error code to <code>MARPA_ERR_PROGRESS_REPORT_EXHAUSTED</code>. 
Either the termination indicator,
or the item count returned by
<code>marpa_r_progress_report_start()</code>,
can be used to determine when the last
item has been seen.

        <p>On success,
the dot position is returned in the location
pointed to by the <var>position</var> argument,
and the origin is returned in the location
pointed to by the <var>origin</var> argument. 
On failure, the locations pointed to by
the <var>position</var> and <var>origin</var>
arguments are unchanged.

        <p>Return value: On success, the rule ID of
the next progress report item. 
If there are no more progress report items, &minus;1. 
If either the <var>position</var> or the <var>origin</var>
argument is <code>NULL</code>,
or on other failure, &minus;2. 
</p></blockquote></div>

<p><a name="Bocage-methods"></a>

<h2 class="chapter">14 Bocage methods</h2>

<p><a name="Bocage-overview"></a>

<h3 class="section">14.1 Overview</h3>

<p>A bocage is structure containing the full set of parses found
by processing the input according to the grammar. 
The bocage structure is new with Libmarpa, but is very similar
in purpose to the more familar parse forests.

   <p>To create a bocage, use the <code>marpa_b_new()</code> method.

   <p>When a bocage is no longer in use, its memory can be freed
using the
<code>marpa_b_unref()</code> method.

<p><a name="Bocage-constructor"></a>

<h3 class="section">14.2 Creating a new bocage</h3>

<div class="defun">
&mdash; Function: Marpa_Bocage <b>marpa_b_new</b> (<var>Marpa_Recognizer r, Marpa_Earley_Set_ID earley_set_ID</var>)<var><a name="index-marpa_005fb_005fnew-80"></a></var><br>
<blockquote>
        <p>Creates a new bocage object, with a reference count of 1. 
The reference count of its parent recognizer object, <var>r</var>,
is increased by 1. 
If there is no parse ending at Earley set <var>earley_set_ID</var>,
<code>marpa_b_new</code> fails
and the error code is set to
<code>MARPA_ERR_NO_PARSE</code>.

        <p>Return value: On success, the new bocage object. 
On failure, <code>NULL</code>. 
</p></blockquote></div>

<p><a name="Bocage-reference-counting"></a>

<h3 class="section">14.3 Reference counting</h3>

<div class="defun">
&mdash; Function: Marpa_Bocage <b>marpa_b_ref</b> (<var>Marpa_Bocage b</var>)<var><a name="index-marpa_005fb_005fref-81"></a></var><br>
<blockquote><p>Increases the reference count by 1. 
Not needed by most applications.

        <p>Return value:
On success, <var>b</var>. 
On failure, <code>NULL</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>marpa_b_unref</b> (<var>Marpa_Bocage b</var>)<var><a name="index-marpa_005fb_005funref-82"></a></var><br>
<blockquote><p>Decreases the reference count by 1,
destroying <var>b</var> once the reference count reaches
zero. 
When <var>b</var> is destroyed, the reference count
of its parent recognizer is decreased by 1. 
If this takes the reference count of the parent recognizer
to zero, it too is destroyed. 
If the parent recognizer is destroyed, the reference count
of its base grammar is decreased by 1. 
If this takes the reference count of the base grammar
to zero, it too is destroyed.

        </blockquote></div>

<p><a name="Bocage-accessor"></a>

<h3 class="section">14.4 Accessors</h3>

<div class="defun">
&mdash; Function: int <b>marpa_b_ambiguity_metric</b> (<var>Marpa_Bocage b</var>)<var><a name="index-marpa_005fb_005fambiguity_005fmetric-83"></a></var><br>
<blockquote><p>Returns an ambiguity metric. 
For the time being, it is vaguely defined, but it does differentiate
between an ambiguous and an unambiguous bocage.

        <p>Return value on success:
1 if the bocage is not for an ambiguous parse;
a number greater than 1 if the bocage is for an ambiguous parse.

        <p>Failures: On failure, &minus;2.

     </blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_b_is_null</b> (<var>Marpa_Bocage b</var>)<var><a name="index-marpa_005fb_005fis_005fnull-84"></a></var><br>
<blockquote><p>Return value on success:
A number greater than or equal to 1 if the bocage is for a null parse;
otherwise, 0.

        <p>Failures: On failure, &minus;2.

        </blockquote></div>

<p><a name="Ordering-methods"></a>

<h2 class="chapter">15 Ordering methods</h2>

<p><a name="Ordering-overview"></a>

<h3 class="section">15.1 Overview</h3>

<p>Before iterating the parses in the bocage,
they must be ordered. 
To create an ordering, use the <code>marpa_o_new()</code> method. 
When an ordering is no longer in use, its memory can be freed
using the
<code>marpa_o_unref()</code> method.

   <p>An ordering is <dfn>frozen</dfn> once the first
tree iterator is created
using it. 
A frozen ordering cannot be changed.

   <p>As of this writing, the only methods to order parses
are internal and undocumented. 
This is expected to change.

<p><a name="Ordering-constructor"></a>

<h3 class="section">15.2 Creating an ordering</h3>

<div class="defun">
&mdash; Function: Marpa_Order <b>marpa_o_new</b> (<var> Marpa_Bocage b</var>)<var><a name="index-marpa_005fo_005fnew-85"></a></var><br>
<blockquote><p>Creates a new ordering object, with a reference count of 1. 
The reference count of its parent bocage object, <var>b</var>,
is increased by 1.

        <p>Return value: On success, the new ordering object. 
On failure, <code>NULL</code>. 
</p></blockquote></div>

<p><a name="Ordering-reference-counting"></a>

<h3 class="section">15.3 Reference counting</h3>

<div class="defun">
&mdash; Function: Marpa_Order <b>marpa_o_ref</b> (<var> Marpa_Order o</var>)<var><a name="index-marpa_005fo_005fref-86"></a></var><br>
<blockquote><p>Increases the reference count by 1. 
Not needed by most applications.

        <p>Return value:
On success, <var>o</var>. 
On failure, <code>NULL</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>marpa_o_unref</b> (<var> Marpa_Order o</var>)<var><a name="index-marpa_005fo_005funref-87"></a></var><br>
<blockquote><p>Decreases the reference count by 1,
destroying <var>o</var> once the reference count reaches
zero. 
Beginning with <var>o</var>'s parent bocage,
Libmarpa then proceeds up the chain of parent objects. 
Every time a child is destroyed, the
reference count of its parent is decreased by 1. 
Every time the reference count of an object
is decreased by 1,
if that reference count is now zero,
that object is destroyed. 
Libmarpa follows this chain of decrements
and destructions as required,
all the way back to the
base grammar, if necessary.

        </blockquote></div>

<p><a name="Order-accessor"></a>

<h3 class="section">15.4 Accessors</h3>

<div class="defun">
&mdash; Function: int <b>marpa_o_ambiguity_metric</b> (<var>Marpa_Order o</var>)<var><a name="index-marpa_005fo_005fambiguity_005fmetric-88"></a></var><br>
<blockquote><p>Returns an ambiguity metric. 
For the time being, it is vaguely defined, but it does differentiate
between an ambiguous and an unambiguous ordering.

        <p>Return value on success:
1 if the ordering is not for an ambiguous parse;
a number greater than 1 if the ordering is for an ambiguous parse.

        <p>Failures: On failure, &minus;2.

     </blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_o_is_null</b> (<var>Marpa_Order o</var>)<var><a name="index-marpa_005fo_005fis_005fnull-89"></a></var><br>
<blockquote><p>Return value on success:
A number greater than or equal to 1 if the ordering is for a null parse;
otherwise, 0.

        <p>Failures: On failure, &minus;2.

        </blockquote></div>

<p><a name="Non-default-ordering"></a>
<a name="Non_002ddefault-ordering"></a>

<h3 class="section">15.5 Non-default ordering</h3>

<div class="defun">
&mdash; Function: int <b>marpa_o_high_rank_only_set</b> (<var> Marpa_Order o, int flag</var>)<var><a name="index-marpa_005fo_005fhigh_005frank_005fonly_005fset-90"></a></var><br>
&mdash; Function: int <b>marpa_o_high_rank_only</b> (<var> Marpa_Order o</var>)<var><a name="index-marpa_005fo_005fhigh_005frank_005fonly-91"></a></var><br>
<blockquote><p>These methods, respectively, set and discover
the &ldquo;high rank only&rdquo; flag of ordering <var>o</var>. 
A <var>flag</var> of 1 indicates that, when ranking,
all choices should be discarded except those of the
highest rank. 
A <var>flag</var> of 0 indicates that
no choices should be discarded on the
basis of their rank.

        <p>A value of 1 is the default. 
The value of the &ldquo;high rank only&rdquo; flag has no effect
unless ranking has been turned on using the
<code>marpa_o_rank()</code> method.

        <p>Return value:  On success, the  value of the
&ldquo;high rank only&rdquo; flag <strong>after</strong>
the call. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_o_rank</b> (<var> Marpa_Order o </var>)<var><a name="index-marpa_005fo_005frank-92"></a></var><br>
<blockquote><p>By default, the ordering of parse trees is arbitrary. 
This method causes the ordering to be ranked
according to the ranks of symbols and rules,
the &ldquo;null ranks high&rdquo; flags of the rules,
and the &ldquo;high rank only&rdquo; flag of the ordering. 
Once this method returns, the ordering is frozen.

        <p>Return value:  On success, a non-negative value. 
On failure, &minus;2.

        </blockquote></div>

<p><a name="Tree-methods"></a>

<h2 class="chapter">16 Tree methods</h2>

<p><a name="Tree-overview"></a>

<h3 class="section">16.1 Overview</h3>

<p>Once the bocage has an ordering, the parses trees can be iterated. 
Marpa's <dfn>parse tree iterators</dfn> iterate the parse trees contained
in a bocage object. 
In Libmarpa,
&ldquo;parse tree iterators&rdquo; are usually just called <dfn>trees</dfn>.

   <p>To create a tree, use the <code>marpa_t_new()</code> method. 
A newly created tree iterator is positioned before the first parse tree. 
When a tree iterator is no longer in use, its memory can be freed
using the
<code>marpa_t_unref()</code> method.

   <p>To position a newly created tree iterator at the first parse tree,
use the <code>marpa_t_next()</code> method. 
Once the tree iterator is positioned at a parse tree,
the same <code>marpa_t_next()</code> method is used
to position it to the next parse tree.

<p><a name="Tree-constructor"></a>

<h3 class="section">16.2 Creating a new tree iterator</h3>

<div class="defun">
&mdash; Function: Marpa_Tree <b>marpa_t_new</b> (<var>Marpa_Order o</var>)<var><a name="index-marpa_005ft_005fnew-93"></a></var><br>
<blockquote><p>Creates a new tree iterator, with a reference count of 1. 
The reference count of its parent ordering object, <var>o</var>,
is increased by 1.

        <p>When initialized, a tree iterator is positioned
before the first parse tree. 
To position the tree iterator to the first parse,
the application must call <code>marpa_t_next()</code>.

        <p>Return value:  On success, a newly created tree. 
On failure, <code>NULL</code>. 
</p></blockquote></div>

<p><a name="Tree-reference-counting"></a>

<h3 class="section">16.3 Reference counting</h3>

<div class="defun">
&mdash; Function: Marpa_Tree <b>marpa_t_ref</b> (<var>Marpa_Tree t</var>)<var><a name="index-marpa_005ft_005fref-94"></a></var><br>
<blockquote><p>Increases the reference count by 1. 
Not needed by most applications.

        <p>Return value:
On success, <var>t</var>. 
On failure, <code>NULL</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>marpa_t_unref</b> (<var>Marpa_Tree t</var>)<var><a name="index-marpa_005ft_005funref-95"></a></var><br>
<blockquote><p>Decreases the reference count by 1,
destroying <var>t</var> once the reference count reaches
zero. 
Beginning with <var>t</var>'s parent ordering,
Libmarpa then proceeds up the chain of parent objects. 
Every time a child is destroyed, the
reference count of its parent is decreased by 1. 
Every time the reference count of an object
is decreased by 1,
if that reference count is now zero,
that object is destroyed. 
Libmarpa follows this chain of decrements
and destructions as required,
all the way back to the
base grammar, if necessary.

        </blockquote></div>

<p><a name="Tree-iteration"></a>

<h3 class="section">16.4 Iterating through the trees</h3>

<div class="defun">
&mdash; Function: int <b>marpa_t_next</b> (<var> Marpa_Tree t</var>)<var><a name="index-marpa_005ft_005fnext-96"></a></var><br>
<blockquote><p>Positions <var>t</var> at the next parse tree
in the iteration. 
Tree iterators are initialized to the position
before the first parse tree,
so this method must be called before creating a valuator
from a tree.

        <p>If a tree iterator is positioned after the last parse,
the tree is said to be &ldquo;exhausted&rdquo;. 
A tree iterator for a bocage with no parse trees
is considered to be &ldquo;exhausted&rdquo; when initialized. 
If the tree iterator is exhausted, <code>marpa_t_next()</code>
returns &minus;1 as a termination indicator,
and sets the error code to
<code>MARPA_ERR_TREE_EXHAUSTED</code>.

        <p>Return value: On success, a non-negative value. 
If the tree iterator is exhausted, &minus;1. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_t_parse_count</b> (<var> Marpa_Tree t</var>)<var><a name="index-marpa_005ft_005fparse_005fcount-97"></a></var><br>
<blockquote><p>The parse counter counts the number of parse trees
traversed so far. 
The count includes the current iteration of the
tree, so that a value of 0 indicates that the tree iterator
is at its initialized position,
before the first parse tree.

        <p>Return value: The number of parses traversed so far. 
Always succeeds. 
</p></blockquote></div>

<p><a name="Value-methods"></a>

<h2 class="chapter">17 Value methods</h2>

<p><a name="Value-overview"></a>

<h3 class="section">17.1 Overview</h3>

<p>The archetypal application needs
a value object (or <dfn>valuator</dfn>) to produce
the value of the parse. 
To create a valuator, use the <code>marpa_v_new()</code> method. 
When a valuator is no longer in use, its memory can be freed
using the
<code>marpa_v_unref()</code> method.

   <p>The application is required to maintain the stack,
and the application is also required to implement
most of the semantics, including the evaluation
of rules. 
Libmarpa's valuator provides instructions to
the application on how to manipulate the stack. 
To iterate through this series of instructions,
use the <code>marpa_v_step()</code> method.

   <p><code>marpa_v_step()</code> returns the type
of step. 
Most step types have values associated with them. 
To access these values use the methods
described in the section <a href="#Basic-step-accessors">Basic step accessors</a>. 
How to perform the steps is described in
the sections
<a href="#How-to-use-the-valuator">How to use the valuator</a>
and <a href="#Stepping-through-the-valuator">Stepping through the valuator</a>.

<p><a name="How-to-use-the-valuator"></a>

<h3 class="section">17.2 How to use the valuator</h3>

<p>Libmarpa's valuator provides the application with
&ldquo;steps&rdquo;, which are
instructions for stack manipulation. 
Libmarpa itself does not maintain a stack. 
This leaves the upper layer in total control of the
stack and the values which are placed on it.

   <p>As example may make this clearer. 
Suppose the evalution is at a place in the parse tree
where an addition is being performed. 
Libmarpa does not know that the operation
is an addition. 
It will tell the application that rule number <var>R</var>
is to be applied to the arguments at stack locations
<var>N</var> and <var>N</var>+1, and that the result is to placed in
stack location <var>N</var>.

   <p>In this system
the application keeps track of the semantics for all
rules, so it looks up rule <var>R</var> and determines that it
is an addition. 
The application can do this by using <var>R</var> as an index
into an array of callbacks, or by any other method
it chooses. 
Let's assume a callback implements the semantics
for rule <var>R</var>. 
Libmarpa has told the application that two arguments
are available for this operation, and that they are
at locations <var>N</var> and <var>N</var>+1 in the stack. 
They might be the numbers 42 and 711. 
So the callback is called with its two arguments,
and produces a return value, let's say, 753. 
Libmarpa has told the application that the result
belongs at location <var>N</var> in the stack,
so the application writes 753 to location <var>N</var>.

   <p>Since Libmarpa knows nothing about the semantics,
the operation for rule R could be string concatenation
instead of addition. 
Or, if it is addition, it could allow for its arguments
to be floating point or complex numbers. 
Since the application maintains the stack, it is up
to the application whether the stack contains integers,
strings, complex numbers, or polymorphic objects which are
capable of being any of these things and more.

<p><a name="Advantages-of-step-driven-valuation"></a>
<a name="Advantages-of-step_002ddriven-valuation"></a>

<h3 class="section">17.3 Advantages of step-driven valuation</h3>

<p>Step-driven valuation
hides Libmarpa's grammar rewrites from the application,
and is quite efficient. 
Libmarpa knows which rules are sequences. 
Libmarpa optimizes stack manipulations based on this knowledge. 
Long sequences
are very common in practical grammars. 
For these,
the stack manipulations suggested by Libmarpa's
step-driven valuator
will be significantly faster than the
traditional stack evaluation algorithm.

   <p>Step-driven evalution has another advantage. 
To illustrate this,
consider what is a very common case:
The semantics are implemented in a higher-level language,
using callbacks. 
If Libmarpa did not use step-driven valuation,
it would need to provide for this case. 
But for generality,
Libmarpa would have to deal in C callbacks. 
Therefore, a middle layer would have to create C language wrappers
for the callbacks in the higher level language.

   <p>The implementation that results is this:
The higher level language would need to wrap each callback in C. 
When calling Libmarpa, it would pass the wrappered callback. 
Libmarpa would then need to call the C language &ldquo;wrappered&rdquo; callback. 
Next, the wrapper would call the higher-level language callback. 
The return value,
which would be data native to the higher-level language,
would need to be passed to the C language wrapper,
which will need to make arrangements for it to be based
back to the higher-level language when appropriate.

   <p>A setup like this is not terribly efficient. 
And exception handling across language boundaries would be
very tricky. 
But neither of these is the worst problem.

   <p>Callbacks are hard to debug. 
Wrappered callbacks are even worse. 
Calls made across language boundaries
are harder yet to debug. 
In the system described above,
by the time a return value is finally consumed,
a language boundary will have been crossed four times.

   <p>How do
programmers deal with difficulties like this? 
Usually, by
doing the absolute minimum possible in the callbacks. 
A horrific debugging enviroment can become a manageable
one if there is next to no code to be debugged. 
And this can be accomplished by
doing as much as possible in pre- and post-processing.

   <p>In essence, callbacks force applications to do most
of the programming
via side effects. 
One need not be a functional programming purist to find
this a very undesirable style of design to force on
an application. 
But the ability to debug can make the difference between
code that does work and code that does not. 
Unfairly or not,
code is rarely considered well-designed when it does
not work.

   <p>So, while step-driven valuation seems
a roundabout approach,
it is simpler and more direct than
the likely alternatives. 
And there is something to be said for pushing
semantics up to the higher levels &mdash;
they can be expected to know more about it.

   <p>These advantages of step-driven valuation
are strictly in
the context of a low-level interface. 
The author is under no illusion
that direct use of Libmarpa's valuator will be found
satisfactory by most application programmers,
even those using the C language. 
The author certainly avoids using step-driven valuation directly. 
Libmarpa's valuator is intended
to be used via an upper layer,
one which <strong>does</strong> know about semantics.

<p><a name="Maintaining-the-stack"></a>

<h3 class="section">17.4 Maintaining the stack</h3>

<p>This section discusses in detail the requirements
for maintaining the stack. 
In some cases,
such as implementation using a Perl array,
fulfilling these requirements is trivial. 
Perl auto-extends its arrays,
and initializes the element values,
on every read or write. 
For the C programmer,
things are not quite so easy.

   <p>In this section,
we will assume a C90 or C99 standard-conformant
C application. 
This assumption is convenient on two grounds. 
First, this will be the intended use
for many readers. 
Second, standard-conformant C is
a &ldquo;worst case&rdquo;. 
Any issue faced by a programmer of another environment
is likely to also be one that must be solved
by the C programmer.

   <p>Libmarpa often
optimizes away unnecessary stack writes
to stack locations. 
When it does so, it will not
necessarily optimize away all reads
to that stack location. 
This means that a location's first access,
as suggested by the Libmarpa step instructions,
may be a read. 
This possibility
requires a special awareness from the C
programmer,
as discussed in
the sections
<a href="#Sizing-the-stack">Sizing the stack</a> and
<a href="#Initializing-locations-in-the-stack">Initializing locations in the stack</a>.

   <p>In the discussions in this document,
stack locations are non-negative integers. 
The bottom of the stack is location 0. 
In moving from the bottom of the stack to the top,
the numbers increase. 
Stack location <var>Y</var> is said to be &ldquo;greater&rdquo;
than stack location <var>X</var> if stack location
<var>Y</var> is closer to the top of stack than location <var>X</var>,
and therefore stack locations are considered greater or
lesser if the integers that represent them are
greater or lesser. 
Another way to state that
a stack location <var>Y</var> is greater (lesser)
than stack location <var>X</var> is to say that
a stack location <var>Y</var> is later (earlier)
than stack location <var>X</var>.

<p><a name="Sizing-the-stack"></a>

<h4 class="subsection">17.4.1 Sizing the stack</h4>

<p>If an implementation applies Libmarpa's step
instructions literally, using a physical stack,
it must make sure the stack is large enough. 
Specifically, the application must do the following

     <ul>
<li>Ensure location 0 exists &mdash; in other
words that the stack is at least length 1. 
<li>For <code>MARPA_STEP_TOKEN</code> steps,
ensure that location <code>marpa_v_result(v)</code>
exists. 
<li>For <code>MARPA_STEP_NULLING_SYMBOL</code> steps,
ensure that location <code>marpa_v_result(v)</code>
exists. 
<li>For <code>MARPA_STEP_RULE</code> steps,
ensure that stack locations from <code>marpa_v_arg_0(v)</code>
to <code>marpa_v_arg_n(v)</code> exist. 
</ul>

   <p>Three aspects of these requirements deserve special mention. 
First,
note that the requirement for a
<code>MARPA_STEP_RULE</code> is that the application
size the stack to include the arguments to be
read. 
Because stack writes may be optimized away,
an application,
when reading,
cannot assume
that the stack was
sized appropriately by a prior write. 
The first access to a new stack location may be
a read.

   <p>Second,
note that there is no explicit requirement that
the application size the stack to include the
location for the result of the
<code>MARPA_STEP_RULE</code> step. 
An application is allowed to assume that
result will go into one of the locations
that were read.

   <p>Third, special note should be made of the requirement
that location 0 exist. 
By convention, the parse result resides
in location 0 of the stack. 
Because of potential optimizations,
an application cannot assume that it
will receive a Libmarpa step instruction that
either reads from or writes to location 0.

<p><a name="Initializing-locations-in-the-stack"></a>

<h4 class="subsection">17.4.2 Initializing locations in the stack</h4>

<p>Write optimizations also creates issues for implementations
which require data to be initialized before reading. 
Every fully standard-conforming C application is such an
implementation. 
Both C90 and C99 allow &ldquo;trap values&rdquo;,
and therefore conforming applications must be
prepared for
an uninitialized location to contain one of those. 
Reading a trap value may cause an abend. 
(It is safe, in standard-conforming C, to write to a location
containing a trap value.)

   <p>The requirement that locations be initialized before
reading occurs in other implementations. 
Any implementation that has a &ldquo;universe&rdquo; of &ldquo;safe&rdquo; values,
may require special precautions. 
The required precautions may amount to a need to initialize
&ldquo;uninitialized&rdquo; values. 
A practical example might be an implementation that expects
all locations to contain a pointer which it can safely indirect
from. 
In such implementations,
just as in standard-conformant C,
every stack location
needs to be initialized before being read.

   <p>Due to write optimizations, an application
cannot rely on Libmarpa's step instructions to
initialize every stack location before its first read. 
One way to safely deal with the
initialization of stack locations,
is to do all of the following:
     <ul>
<li>When starting evaluation, ensure that the stack contains at least location 0. 
<li>Also, when starting evaluation, initialize every location in the stack. 
<li>Whenever the stack is extended,
initialize every stack location added. 
</ul>

   <p>Applications which try to optimize out some of
these initializations
need to be aware that
an application can never assume that activity in
the stack is safely &ldquo;beyond&rdquo; an uninitialized location. 
Libmarpa steps often revisit earlier sections of the stack,
and these revisits may include reads of previously
unvisited stack locations.

<p><a name="Valuator-constructor"></a>

<h3 class="section">17.5 Creating a new valuator</h3>

<div class="defun">
&mdash; Function: Marpa_Value <b>marpa_v_new</b> (<var> Marpa_Tree t </var>)<var><a name="index-marpa_005fv_005fnew-98"></a></var><br>
<blockquote><p>Creates a new valuator. 
The parent object of the new valuator
will be the tree iterator <var>t</var>,
and the reference count of the new valuator will be 1. 
The reference count of <var>t</var> is increased by 1.

        <p>The parent tree iterator is &ldquo;paused&rdquo;,
so that the tree iterator
cannot move on to a new parse tree
until the valuator is destroyed. 
Many valuators of the same parse tree
can exist at once. 
A tree iterator is &ldquo;unpaused&rdquo; when
all of the valuators of that tree iterator are destroyed.

        <p>Return value:  On success, the newly created valuator. 
On failure, <code>NULL</code>. 
</p></blockquote></div>

<p><a name="Valuator-reference-counting"></a>

<h3 class="section">17.6 Reference counting</h3>

<div class="defun">
&mdash; Function: Marpa_Value <b>marpa_v_ref</b> (<var>Marpa_Value v</var>)<var><a name="index-marpa_005fv_005fref-99"></a></var><br>
<blockquote><p>Increases the reference count by 1. 
Not needed by most applications.

        <p>Return value:
On success, <var>v</var>. 
On failure, <code>NULL</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>marpa_v_unref</b> (<var> Marpa_Value v</var>)<var><a name="index-marpa_005fv_005funref-100"></a></var><br>
<blockquote><p>Decreases the reference count by 1,
destroying <var>v</var> once the reference count reaches
zero. 
Beginning with <var>v</var>'s parent tree,
Libmarpa then proceeds up the chain of parent objects. 
Every time a child is destroyed, the
reference count of its parent is decreased by 1. 
Every time the reference count of an object
is decreased by 1,
if that reference count is now zero,
that object is destroyed. 
Libmarpa follows this chain of decrements
and destructions as required,
all the way back to the
base grammar, if necessary.

        </blockquote></div>

<p><a name="Stepping-through-the-valuator"></a>

<h3 class="section">17.7 Stepping through the valuator</h3>

<div class="defun">
&mdash; Function: Marpa_Step_Type <b>marpa_v_step</b> (<var> Marpa_Value v</var>)<var><a name="index-marpa_005fv_005fstep-101"></a></var><br>
<blockquote><p>This method &ldquo;steps through&rdquo; the valuator. 
The return value is a <code>Marpa_Step_Type</code>,
an integer which indicates the type of step. 
How the application is expected to act on
each step is described below. 
See <a href="#Valuator-steps-by-type">Valuator steps by type</a>. 
When the iteration through the steps is finished,
<code>marpa_v_step</code> returns <code>MARPA_STEP_INACTIVE</code>.

        <p>Return value:  On success, the type of the step
to be performed. 
This will always be a non-negative number. 
On failure, &minus;2. 
</p></blockquote></div>

<p><a name="Valuator-steps-by-type"></a>

<h3 class="section">17.8 Valuator steps by type</h3>

<div class="defun">
&mdash; Macro: Marpa_Step_Type <b>MARPA_STEP_RULE</b><var><a name="index-MARPA_005fSTEP_005fRULE-102"></a></var><br>
<blockquote><p>The semantics of a rule should be performed. 
The application can find the value of the rule's
children in the stack locations from
<code>marpa_v_arg_0(v)</code>
to <code>marpa_v_arg_n(v)</code>. 
The semantics for the rule whose ID is
<code>marpa_v_rule(v)</code> should be executed
on these child values,
and the result placed in
<code>marpa_v_result(v)</code>. 
In the case of a <code>MARPA_STEP_RULE</code> step,
the stack location of
<code>marpa_v_result(v)</code> is guaranteed to
be equal to <code>marpa_v_arg_0(v)</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: Marpa_Step_Type <b>MARPA_STEP_TOKEN</b><var><a name="index-MARPA_005fSTEP_005fTOKEN-103"></a></var><br>
<blockquote><p>The semantics of a non-null token should be performed. 
The application's value for the token whose ID is
<code>marpa_v_token(v)</code> should be
placed in
stack location <code>marpa_v_result(v)</code>. 
Its value according to Libmarpa will be in
<code>marpa_v_token_value(v)</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: Marpa_Step_Type <b>MARPA_STEP_NULLING_SYMBOL</b><var><a name="index-MARPA_005fSTEP_005fNULLING_005fSYMBOL-104"></a></var><br>
<blockquote><p>The semantics for a nulling symbol should be performed. 
The ID of the symbol is
<code>marpa_v_symbol(v)</code> and its value should
be placed in
stack location <code>marpa_v_result(v)</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: Marpa_Step_Type <b>MARPA_STEP_INACTIVE</b><var><a name="index-MARPA_005fSTEP_005fINACTIVE-105"></a></var><br>
<blockquote><p>The valuator has gone through all of its steps
and is now inactive. 
The value of the parse will be in stack location 0. 
Because of optimizations,
it is possible for valuator to immediately
became inactive &mdash; <code>MARPA_STEP_INACTIVE</code> could
be both the first and last step.

        </blockquote></div>

<div class="defun">
&mdash; Macro: Marpa_Step_Type <b>MARPA_STEP_INITIAL</b><var><a name="index-MARPA_005fSTEP_005fINITIAL-106"></a></var><br>
<blockquote><p>The valuator is new and has
yet to go through any steps. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: Marpa_Step_Type <b>MARPA_STEP_INTERNAL1</b><var><a name="index-MARPA_005fSTEP_005fINTERNAL1-107"></a></var><br>
&mdash; Macro: Marpa_Step_Type <b>MARPA_STEP_INTERNAL2</b><var><a name="index-MARPA_005fSTEP_005fINTERNAL2-108"></a></var><br>
&mdash; Macro: Marpa_Step_Type <b>MARPA_STEP_TRACE</b><var><a name="index-MARPA_005fSTEP_005fTRACE-109"></a></var><br>
<blockquote><p>These step types are reserved for internal purposes. 
</p></blockquote></div>

<p><a name="Basic-step-accessors"></a>

<h3 class="section">17.9 Basic step accessors</h3>

<p>The basic step accessors are so called because their information
is basic to the stack manipulation. 
The basic step accessors are implemented as macros. 
They always succeed.

<div class="defun">
&mdash; Macro: int <b>marpa_v_arg_0</b> (<var>Marpa_Value v</var>)<var><a name="index-marpa_005fv_005farg_005f0-110"></a></var><br>
<blockquote><p>For a <code>MARPA_STEP_RULE</code> step,
returns the stack location where the value of first child
can be found. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>marpa_v_arg_n</b> (<var>Marpa_Value v</var>)<var><a name="index-marpa_005fv_005farg_005fn-111"></a></var><br>
<blockquote><p>For a <code>MARPA_STEP_RULE</code> step,
returns the stack location where the value of the last child
can be found. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>marpa_v_result</b> (<var>Marpa_Value v</var>)<var><a name="index-marpa_005fv_005fresult-112"></a></var><br>
<blockquote><p>For <code>MARPA_STEP_RULE</code>,
<code>MARPA_STEP_TOKEN</code>,
and <code>MARPA_STEP_NULLING_SYMBOL</code> steps,
returns the stack location where the result of the semantics
should be placed. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: Marpa_Rule_ID <b>marpa_v_rule</b> (<var>Marpa_Value v</var>)<var><a name="index-marpa_005fv_005frule-113"></a></var><br>
<blockquote><p>For the
<code>MARPA_STEP_RULE</code> step,
returns the ID of the rule. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: Marpa_Step_Type <b>marpa_v_step_type</b> (<var>Marpa_Value v</var>)<var><a name="index-marpa_005fv_005fstep_005ftype-114"></a></var><br>
<blockquote><p>Returns the current step type:
<code>MARPA_STEP_TOKEN</code>,
<code>MARPA_STEP_RULE</code>,
etc. 
Usually not needed since this is also the return value of
<code>marpa_v_step()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: Marpa_Symbol_ID <b>marpa_v_symbol</b> (<var>Marpa_Value v</var>)<var><a name="index-marpa_005fv_005fsymbol-115"></a></var><br>
<blockquote><p>For the <code>MARPA_STEP_NULLING_SYMBOL</code> step,
returns the ID of the symbol. 
The value returned is the same as that
returned by the <code>marpa_v_token()</code>
macro. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: Marpa_Symbol_ID <b>marpa_v_token</b> (<var>Marpa_Value v</var>)<var><a name="index-marpa_005fv_005ftoken-116"></a></var><br>
<blockquote><p>For the <code>MARPA_STEP_TOKEN</code> step,
returns the ID of the token. 
The value returned is the same as that
returned by the <code>marpa_v_symbol()</code>
macro. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>marpa_v_token_value</b> (<var>Marpa_Value v</var>)<var><a name="index-marpa_005fv_005ftoken_005fvalue-117"></a></var><br>
<blockquote><p>For the <code>MARPA_STEP_TOKEN</code> step,
returns the integer which is
(or which represents)
the value of the token. 
</p></blockquote></div>

<p><a name="Other-step-accessors"></a>

<h3 class="section">17.10 Other step accessors</h3>

<p>This section contains the step accessors that
are not basic to stack manipulation, but which provide
other useful information about the parse. 
These step accessors are implemented as macros.

   <p>All of these accessors always succeed, but
if called when they are irrelevant
they return an unspecified value. 
In this context, an &ldquo;unspecified value&rdquo; is a value
that is either &minus;1 or the ID of a valid Earley set,
but which is otherwise unpredictable.

<div class="defun">
&mdash; Macro: Marpa_Earley_Set_ID <b>marpa_v_es_id</b> (<var>Marpa_Value v</var>)<var><a name="index-marpa_005fv_005fes_005fid-118"></a></var><br>
<blockquote><p>Return value:
If the current step type is <code>MARPA_STEP_RULE</code>,
the Earley Set ordinal where the rule ends. 
If the current step type is
<code>MARPA_STEP_TOKEN</code>
or <code>MARPA_STEP_NULLING_SYMBOL</code>,
the Earley Set ordinal where the symbol ends. 
If the current step type is anything else, an unspecified value. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: Marpa_Earley_Set_ID <b>marpa_v_rule_start_es_id</b> (<var>Marpa_Value v</var>)<var><a name="index-marpa_005fv_005frule_005fstart_005fes_005fid-119"></a></var><br>
<blockquote><p>Return value:
If the current step type is <code>MARPA_STEP_RULE</code>,
the Earley Set ordinal where the rule begins. 
If the current step type is anything else, an unspecified value. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: Marpa_Earley_Set_ID <b>marpa_v_token_start_es_id</b> (<var>Marpa_Value v</var>)<var><a name="index-marpa_005fv_005ftoken_005fstart_005fes_005fid-120"></a></var><br>
<blockquote><p>Return value:
If the current step type is <code>MARPA_STEP_TOKEN</code>
or <code>MARPA_STEP_NULLING_SYMBOL</code>,
the Earley Set ordinal where the token begins. 
If the current step type is anything else, an unspecified value. 
</p></blockquote></div>

<p><a name="Events"></a>

<h2 class="chapter">18 Events</h2>

<p><a name="Events-overview"></a>

<h3 class="section">18.1 Overview</h3>

<p>Events are generated by the
<code>marpa_g_precompute()</code>,
<code>marpa_r_earleme_complete()</code>,
and
<code>marpa_r_start_input()</code> methods. 
The methods are called event-active. 
Event-active methods always clear all previous events,
so that after an event-active method the only events
available
will be those generated by that method.

   <p>Events are volatile,
and it is expected that events will be queried
immediately after the method that generated them. 
Note especially
that multiple recognizers using the same base grammar
overwrite each other's events.

   <p>To find out how many events were generated by the last
event-active method,
use the <code>marpa_g_event_count</code> method.

   <p>To query a specific event,
use the <code>marpa_g_event</code> and
<code>marpa_g_event_value</code> methods.

<p><a name="Event-methods"></a>

<h3 class="section">18.2 Methods</h3>

<div class="defun">
&mdash; Function: Marpa_Event_Type <b>marpa_g_event</b> (<var>Marpa_Grammar g, Marpa_Event* event, int ix</var>)<var><a name="index-marpa_005fg_005fevent-121"></a></var><br>
<blockquote><p>On success,
the type of the <var>ix</var>'th event is returned
and the data for the <var>ix</var>'th event is placed
in the location pointed to by <var>event</var>.

        <p>Event indexes are in sequence. 
Valid events will be in the range from 0 to <var>n</var>,
where <var>n</var> is one less than the event count. 
The event count
can be queried using the <code>marpa_g_event_count()</code>
method.

        <p>Return value:  On success, the type of event <var>ix</var>. 
If there is no <var>ix</var>'th event,
if <var>ix</var> is negative,
or on other failure, &minus;2. 
On failure,
the locations pointed to by <var>event</var>
are not changed. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_g_event_count</b> (<var> Marpa_Grammar g </var>)<var><a name="index-marpa_005fg_005fevent_005fcount-122"></a></var><br>
<blockquote><p>Return value:  On success, the number of events. 
On failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>marpa_g_event_value</b> (<var>Marpa_Event* event</var>)<var><a name="index-marpa_005fg_005fevent_005fvalue-123"></a></var><br>
<blockquote><p>This macro provides access to the &ldquo;value&rdquo; of the event. 
The semantics of the value varies according to the type
of the event, and is described in the section on event
codes. 
See <a href="#Event-codes">Event codes</a>. 
</p></blockquote></div>

<p><a name="Event-codes"></a>

<h3 class="section">18.3 Event codes</h3>

<div class="defun">
&mdash; Macro: int <b>MARPA_EVENT_NONE</b><var><a name="index-MARPA_005fEVENT_005fNONE-124"></a></var><br>
<blockquote><p>Applications should never see this event. 
Event value: Undefined. 
Suggested message: "No event". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_EVENT_COUNTED_NULLABLE</b><var><a name="index-MARPA_005fEVENT_005fCOUNTED_005fNULLABLE-125"></a></var><br>
<blockquote><p>A nullable symbol is either the separator
for, or the right hand side of, a sequence. 
Event value: The ID of the symbol. 
Suggested message: "This symbol is a counted nullable". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_EVENT_EARLEY_ITEM_THRESHOLD</b><var><a name="index-MARPA_005fEVENT_005fEARLEY_005fITEM_005fTHRESHOLD-126"></a></var><br>
<blockquote><p>This event indicates the current Earley item count
exceeded a
user-settable threshold. 
Event value: The current Earley item count. 
Suggested message: "Too many Earley items". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_EVENT_EXHAUSTED</b><var><a name="index-MARPA_005fEVENT_005fEXHAUSTED-127"></a></var><br>
<blockquote><p>The parse is exhausted. 
Event value: Undefined. 
Suggested message: "Recognizer is exhausted". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_EVENT_LOOP_RULES</b><var><a name="index-MARPA_005fEVENT_005fLOOP_005fRULES-128"></a></var><br>
<blockquote><p>One or more rules are loop rules &mdash; rules
that are part of a cycle. 
Cycles are pathological cases of recursion,
in which the same symbol string derives itself
a potentially infinite number of times. 
Nonetheless, Marpa parses in the presence of these,
and it is up to the application to treat these
as fatal errors,
something they almost always will wish to do. 
Event value: The count of loop rules. 
Suggested message: "Grammar contains a infinite loop". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_EVENT_NULLING_TERMINAL</b><var><a name="index-MARPA_005fEVENT_005fNULLING_005fTERMINAL-129"></a></var><br>
<blockquote><p>A nulling symbol is also a terminal. 
Event value: The ID of the symbol. 
Suggested message: "This symbol is a nulling terminal". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_EVENT_SYMBOL_COMPLETED</b><var><a name="index-MARPA_005fEVENT_005fSYMBOL_005fCOMPLETED-130"></a></var><br>
<blockquote><p>The recognizer can be set to generate an event
a symbol is completed
using its <code>marpa_g_symbol_is_completion_event_set()</code>
method. 
(A symbol is "completed" if and only if any rule with that symbol
as its LHS is completed.) 
This event code indicates that one of those events
occurred. 
Event value: The ID of the completed symbol. 
Suggested message: "Completed symbol". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_EVENT_SYMBOL_EXPECTED</b><var><a name="index-MARPA_005fEVENT_005fSYMBOL_005fEXPECTED-131"></a></var><br>
<blockquote><p>The recognizer can be set to generate an event when a
symbol is expected as a terminal,
using its <code>marpa_r_expected_symbol_event_set()</code>
method. 
Note that this event only triggers if the symbol is
expected as a terminal. 
Predicted symbols which are not expected as terminals
do not trigger this event. 
This event code indicates that one of those events
occurred. 
Event value: The ID of the expected symbol. 
Suggested message: "Expecting symbol". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_EVENT_SYMBOL_NULLED</b><var><a name="index-MARPA_005fEVENT_005fSYMBOL_005fNULLED-132"></a></var><br>
<blockquote><p>The recognizer can be set to generate an event when a
symbol is nulled &ndash; that is, recognized as a
zero-length symbol. 
To set an nulled symbol event,
use the recognizer's <code>marpa_r_nulled_symbol_event_set()</code>
method. 
This event code indicates that a nulled symbol event
occurred. 
Event value: The ID of the nulled symbol. 
Suggested message: "Symbol was nulled". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_EVENT_SYMBOL_PREDICTED</b><var><a name="index-MARPA_005fEVENT_005fSYMBOL_005fPREDICTED-133"></a></var><br>
<blockquote><p>The recognizer can be set to generate an event when a
symbol is predicted. 
To set an predicted symbol event,
use the recognizer's <code>marpa_r_predicted_symbol_event_set()</code>
method. 
Unlike the
<code>MARPA_EVENT_SYMBOL_EXPECTED</code> event,
the <code>MARPA_EVENT_SYMBOL_PREDICTED</code> event
triggers for predictions of both
non-terminals and terminals. 
This event code indicates that a predicted symbol event
occurred. 
Event value: The ID of the predicted symbol. 
Suggested message: "Symbol was predicted". 
</p></blockquote></div>

<p><a name="Error-methods-macros-and-codes"></a>

<h2 class="chapter">19 Error methods, macros and codes</h2>

<p><a name="Error-methods"></a>

<h3 class="section">19.1 Error methods</h3>

<div class="defun">
&mdash; Function: Marpa_Error_Code <b>marpa_g_error</b> (<var> Marpa_Grammar g, const char** p_error_string</var>)<var><a name="index-marpa_005fg_005ferror-134"></a></var><br>
<blockquote><p>When a method fails,
this method allows the application to read
the error code. 
<var>p_error_string</var> is reserved for use by
the internals. 
Applications should set it to <code>NULL</code>.

        <p>Return value: The last error code from a Libmarpa method. 
Always succeeds. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Error_Code <b>marpa_g_error_clear</b> (<var> Marpa_Grammar g </var>)<var><a name="index-marpa_005fg_005ferror_005fclear-135"></a></var><br>
<blockquote>
        <p>Sets the error code
to <code>MARPA_ERR_NONE</code>. 
Not often used,
but now and then it can be useful
to force the error code to a known state.

        <p>Return value: <code>MARPA_ERR_NONE</code>. 
Always succeeds. 
</p></blockquote></div>

<p><a name="Error-Macros"></a>

<h3 class="section">19.2 Error Macros</h3>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERRCODE_COUNT</b><var><a name="index-MARPA_005fERRCODE_005fCOUNT-136"></a></var><br>
<blockquote><p>The number of error codes. 
All error codes, whether internal or external,
will be integers, non-negative but
strictly less than <code>MARPA_ERRCODE_COUNT</code>. 
</p></blockquote></div>

<p><a name="External-error-codes"></a>

<h3 class="section">19.3 External error codes</h3>

<p>This section lists the external error codes. 
These are the only error codes that users
of the Libmarpa external interface should ever see. 
Internal error codes are in their own section. 
See <a href="#Internal-error-codes">Internal error codes</a>.

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NONE</b><var><a name="index-MARPA_005fERR_005fNONE-137"></a></var><br>
<blockquote><p>No error condition. 
The error code is initialized to this value. 
Methods which do not result in failure
sometimes reset the error code to <code>MARPA_ERR_NONE</code>. 
Numeric value: 0. 
Suggested message: "No error". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_BAD_SEPARATOR</b><var><a name="index-MARPA_005fERR_005fBAD_005fSEPARATOR-138"></a></var><br>
<blockquote><p>A separator was specified for a sequence rule,
but its ID was not that
of a valid symbol. 
Numeric value: 6. 
Suggested message: "Separator has invalid symbol ID". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_BEFORE_FIRST_TREE</b><var><a name="index-MARPA_005fERR_005fBEFORE_005fFIRST_005fTREE-139"></a></var><br>
<blockquote><p>A tree iterator is positioned before the first tree,
and it was specified in a context where that is not
allowed. 
A newly created tree is positioned before the first
tree. 
To position a newly created tree iterator to the first tree
use the <code>marpa_t_next()</code> method. 
Numeric value: 91. 
Suggested message: "Tree iterator is before first tree". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_COUNTED_NULLABLE</b><var><a name="index-MARPA_005fERR_005fCOUNTED_005fNULLABLE-140"></a></var><br>
<blockquote><p>A &ldquo;counted&rdquo; symbol was found
that is also a nullable symbol. 
A &ldquo;counted&rdquo; symbol is one that appears on the RHS
of a sequence rule. 
If a symbol is nullable,
counting its occurrences becomes difficult. 
Questions of definition and
problems of implementation arise. 
At a minimum, a sequence with counted nullables
would be wildly
ambigious.

        <p>Sequence rules are simply an optimized shorthand
for rules that can also be written in ordinary BNF. 
If the equivalent of a sequence of nullables is
really what your application needs,
nothing in Libmarpa prevents you from specifying
that sequence
with ordinary BNF rules.

        <p>Numeric value: 8. 
Suggested message: "Nullable symbol on RHS of a sequence rule". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_DUPLICATE_RULE</b><var><a name="index-MARPA_005fERR_005fDUPLICATE_005fRULE-141"></a></var><br>
<blockquote><p>This error indicates an attempt to add a BNF rule which
is a duplicate of a BNF rule already in the grammar. 
Two BNF rules are considered duplicates if

          <ul>
<li>Both rules have the same left hand symbol, and
<li>Both rules have the same right hand symbols in the same order. 
</ul>

        <p>Duplication of sequence rules,
and duplication between BNF rules and sequence rules,
is dealt with by requiring that the LHS of a sequence rule
not be the LHS of any other rule.

        <p>Numeric value: 11. 
Suggested message: "Duplicate rule". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_DUPLICATE_TOKEN</b><var><a name="index-MARPA_005fERR_005fDUPLICATE_005fTOKEN-142"></a></var><br>
<blockquote><p>This error indicates an attempt to add a duplicate token. 
A token is a duplicate if one already read at the same
earleme has the same symbol ID and the same length. 
Numeric value: 12. 
Suggested message: "Duplicate token". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_YIM_COUNT</b><var><a name="index-MARPA_005fERR_005fYIM_005fCOUNT-143"></a></var><br>
<blockquote><p>This error code indicates that
an implementation-defined limit on the
number of Earley items per Earley set
was exceedeed. 
This limit is different from
the Earley item warning threshold,
an optional limit on the number
of Earley items in an Earley set,
which can be set by the application.

        <p>The implementation defined-limit is very large,
at least 500,000,000 earlemes. 
An application is unlikely ever to see this
error. 
Libmarpa's use of memory
would almost certainly exceed the implementation's
limits before it occurred. 
Numeric value: 13. 
Suggested message: "Maximum number of Earley items exceeded". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_EVENT_IX_NEGATIVE</b><var><a name="index-MARPA_005fERR_005fEVENT_005fIX_005fNEGATIVE-144"></a></var><br>
<blockquote><p>A negative event index was specified. 
That is not allowed. 
Numeric value: 15. 
Suggested message: "Negative event index". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_EVENT_IX_OOB</b><var><a name="index-MARPA_005fERR_005fEVENT_005fIX_005fOOB-145"></a></var><br>
<blockquote><p>An non-negative event index was specified,
but there is no event at that index. 
Since the events are in sequence, this means it
was too large. 
Numeric value: 16. 
Suggested message: "No event at that index". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_GRAMMAR_HAS_CYCLE</b><var><a name="index-MARPA_005fERR_005fGRAMMAR_005fHAS_005fCYCLE-146"></a></var><br>
<blockquote><p>The grammar has a cycle &mdash; one or more loop
rules. 
This is a recoverable error,
although most applications will want to treat
it as fatal. 
For more see the description of <a href="#marpa_005fg_005fprecompute">marpa_g_precompute</a>. 
Numeric value: 17. 
Suggested message: "Grammar has cycle". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_HEADERS_DO_NOT_MATCH</b><var><a name="index-MARPA_005fERR_005fHEADERS_005fDO_005fNOT_005fMATCH-147"></a></var><br>
<blockquote><p>This is an internal error, and indicates that
Libmarpa was wrongly built. 
Libmarpa was compiled with headers which do not
match the rest of the code. 
The solution is to find a correctly built
Libmarpa. 
Numeric value: 98. 
Suggested message: "Internal error: Libmarpa was built incorrectly"
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_I_AM_NOT_OK</b><var><a name="index-MARPA_005fERR_005fI_005fAM_005fNOT_005fOK-148"></a></var><br>
<blockquote><p>The Libmarpa base grammar is in a "not ok"
state. 
Currently, the only way this can happen
is if Libmarpa memory is being overwritten. 
Numeric value: 29. 
Suggested message: "Marpa is in a not OK state". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_INACCESSIBLE_TOKEN</b><var><a name="index-MARPA_005fERR_005fINACCESSIBLE_005fTOKEN-149"></a></var><br>
<blockquote><p>This error code indicates that
the token symbol is an inaccessible symbol &mdash; one which
cannot be reached from the start symbol.

        <p>Since the inaccessibility of a symbol is a property of the grammar,
this error code typically indicates an application error. 
Nevertheless, a retry at this location, using another token ID,
may succeed. 
At this writing,
the author knows of no uses of this technique.

        <p>Numeric value: 18. 
Suggested message: "Token symbol is inaccessible". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_INVALID_BOOLEAN</b><var><a name="index-MARPA_005fERR_005fINVALID_005fBOOLEAN-150"></a></var><br>
<blockquote><p>A function was called that takes a boolean argument,
but the value of that argument was not either 0 or 1. 
Numeric value: 22. 
Suggested message: "Argument is not boolean". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_INVALID_LOCATION</b><var><a name="index-MARPA_005fERR_005fINVALID_005fLOCATION-151"></a></var><br>
<blockquote><p>The location (Earley set ID) is not valid. 
It may be invalid for one of two reasons:
          <ul>
<li>It is negative,
and it is being used as the argument to a method
for which that negative value does not have a special meaning. 
<li>It is after the latest Earley set. 
</ul>

        <p>For users of input models other than the standard one,
the term &ldquo;location&rdquo;, as used in association
with this error code,
means Earley set ID or Earley set ordinal. 
In the standard input model, this will always
be identical with Libmarpa's other idea of
location, the earleme.

        <p>Numeric value: 25. 
Suggested message: "Location is not valid". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_INVALID_START_SYMBOL</b><var><a name="index-MARPA_005fERR_005fINVALID_005fSTART_005fSYMBOL-152"></a></var><br>
<blockquote><p>A start symbol was specified,
but its symbol ID is not that of a valid symbol. 
Numeric value: 27. 
Suggested message: "Specified start symbol is not valid". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_INVALID_ASSERTION_ID</b><var><a name="index-MARPA_005fERR_005fINVALID_005fASSERTION_005fID-153"></a></var><br>
<blockquote><p>A method was called with an invalid assertion ID. 
This is a assertion ID which not only does
not exist, but cannot exist. 
Currently that means its value is less than zero. 
Numeric value: 96. 
Suggested message: "Assertion ID is malformed". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_INVALID_RULE_ID</b><var><a name="index-MARPA_005fERR_005fINVALID_005fRULE_005fID-154"></a></var><br>
<blockquote><p>A method was called with an invalid rule ID. 
This is a rule ID which not only does
not exist, but cannot exist. 
Currently that means its value is less than zero. 
Numeric value: 26. 
Suggested message: "Rule ID is malformed". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_INVALID_SYMBOL_ID</b><var><a name="index-MARPA_005fERR_005fINVALID_005fSYMBOL_005fID-155"></a></var><br>
<blockquote><p>A method was called with an invalid symbol ID. 
This is a symbol ID which not only does
not exist, but cannot exist. 
Currently that means its value is less than zero. 
Numeric value: 28. 
Suggested message: "Symbol ID is malformed". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_MAJOR_VERSION_MISMATCH</b><var><a name="index-MARPA_005fERR_005fMAJOR_005fVERSION_005fMISMATCH-156"></a></var><br>
<blockquote><p>There was a mismatch in the major version number
between the requested version
of libmarpa, and the actual one. 
Numeric value: 30. 
Suggested message: "Libmarpa major version number is a mismatch".

        </blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_MICRO_VERSION_MISMATCH</b><var><a name="index-MARPA_005fERR_005fMICRO_005fVERSION_005fMISMATCH-157"></a></var><br>
<blockquote><p>There was a mismatch in the micro version number
between the requested version
of libmarpa, and the actual one. 
Numeric value: 31. 
Suggested message: "Libmarpa micro version number is a mismatch". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_MINOR_VERSION_MISMATCH</b><var><a name="index-MARPA_005fERR_005fMINOR_005fVERSION_005fMISMATCH-158"></a></var><br>
<blockquote><p>There was a mismatch in the minor version number
between the requested version
of libmarpa, and the actual one. 
Numeric value: 32. 
Suggested message: "Libmarpa minor version number is a mismatch". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_EARLEY_SET_AT_LOCATION</b><var><a name="index-MARPA_005fERR_005fNO_005fEARLEY_005fSET_005fAT_005fLOCATION-159"></a></var><br>
<blockquote><p>A non-negative Earley set ID (also called an Earley set ordinal)
was specified,
but there is no corresponding Earley set. 
Since the Earley set ordinals are in sequence,
this means that the specified ID is greater
than that of the latest Earley set. 
Numeric value: 39. 
Suggested message: "Earley set ID is after latest Earley set". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NOT_PRECOMPUTED</b><var><a name="index-MARPA_005fERR_005fNOT_005fPRECOMPUTED-160"></a></var><br>
<blockquote><p>The grammar is not precomputed,
and attempt was made to do something with it
that is not allowed for unprecomputed
grammars. 
For example, a recognizer cannot be
created from a grammar until it is precomputed. 
Numeric value: 34. 
Suggested message: "This grammar is not precomputed". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_PARSE</b><var><a name="index-MARPA_005fERR_005fNO_005fPARSE-161"></a></var><br>
<blockquote><p>The application attempted to create a bocage
from a recognizer without a parse. 
Applications will often want to treat this as
a soft error. 
Numeric value: 41. 
Suggested message: "No parse". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_RULES</b><var><a name="index-MARPA_005fERR_005fNO_005fRULES-162"></a></var><br>
<blockquote><p>A grammar which has no rules is being used
in a way that is not allowed. 
Usually the problem is that the user is
trying to precompute the grammar. 
Numeric value: 42. 
Suggested message: "This grammar does not have any rules". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_START_SYMBOL</b><var><a name="index-MARPA_005fERR_005fNO_005fSTART_005fSYMBOL-163"></a></var><br>
<blockquote><p>The grammar has no start symbol,
and an attempt was made to perform an
operation which requires one. 
Usually the problem is that the user is
trying to precompute the grammar. 
Numeric value: 43. 
Suggested message: "This grammar has no start symbol". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_SUCH_ASSERTION_ID</b><var><a name="index-MARPA_005fERR_005fNO_005fSUCH_005fASSERTION_005fID-164"></a></var><br>
<blockquote><p>A method was called with an assertion ID which is well-formed,
but the assertion does not exist. 
Numeric value: 97. 
Suggested message: "No assertion with this ID exists". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_SUCH_RULE_ID</b><var><a name="index-MARPA_005fERR_005fNO_005fSUCH_005fRULE_005fID-165"></a></var><br>
<blockquote><p>A method was called with a rule ID which is well-formed,
but the rule does not exist. 
Numeric value: 89. 
Suggested message: "No rule with this ID exists". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_SUCH_SYMBOL_ID</b><var><a name="index-MARPA_005fERR_005fNO_005fSUCH_005fSYMBOL_005fID-166"></a></var><br>
<blockquote><p>A method was called with a symbol ID which is well-formed,
but the symbol does not exist. 
Numeric value: 90. 
Suggested message: "No symbol with this ID exists". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_TOKEN_EXPECTED_HERE</b><var><a name="index-MARPA_005fERR_005fNO_005fTOKEN_005fEXPECTED_005fHERE-167"></a></var><br>
<blockquote><p>This error code indicates that
no tokens at all were expected at this earleme
location. 
This can only happen in alternative input models.

        <p>Typically, this indicates an application programming
error. 
Retrying input at this location will always fail. 
But if the application is able to leave this
earleme empty, a retry at a later location,
using this or another token,
may succeed. 
At this writing,
the author knows of no uses of this technique.

        <p>Numeric value: 44. 
Suggested message: "No token is expected at this earleme location". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NULLING_TERMINAL</b><var><a name="index-MARPA_005fERR_005fNULLING_005fTERMINAL-168"></a></var><br>
<blockquote><p>Marpa does not allow a symbol to be both nulling
and a terminal. 
Numeric value: 49. 
Suggested message: "A symbol is both terminal and nulling". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_ORDER_FROZEN</b><var><a name="index-MARPA_005fERR_005fORDER_005fFROZEN-169"></a></var><br>
<blockquote><p>The Marpa order object has been frozen. 
If a Marpa order object is frozen, it cannot be
changed.

        <p>Multiple tree iterators can share a Marpa order object,
but that order object is frozen after the first tree
iterator is created from it. 
Applications can order an bocage in many ways,
but they must do so by creating multiple order objects.

        <p>Numeric value: 50. 
Suggested message: "The ordering is frozen". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_PARSE_EXHAUSTED</b><var><a name="index-MARPA_005fERR_005fPARSE_005fEXHAUSTED-170"></a></var><br>
<blockquote><p>The parse is exhausted. 
Numeric value: 53. 
Suggested message: "The parse is exhausted". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_PARSE_TOO_LONG</b><var><a name="index-MARPA_005fERR_005fPARSE_005fTOO_005fLONG-171"></a></var><br>
<blockquote><p>The parse is too long. 
The limit on the length of a parse is implementation
dependent, but it is very large,
at least 500,000,000 earlemes.

        <p>This error code is unlikely in the standard input model. 
Almost certainly memory would be exceeded
before it could occur. 
If an application sees this error,
it almost certainly using one of the non-standard
input models.

        <p>Most often this messsage will occur because
of a request to add a single extremely long token,
perhaps as a result of an application error. 
But it is also possible this error condition will
occur after the input of a large number
of long tokens.

        <p>Numeric value: 54. 
Suggested message: "This input would make the parse too long". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_POINTER_ARG_NULL</b><var><a name="index-MARPA_005fERR_005fPOINTER_005fARG_005fNULL-172"></a></var><br>
<blockquote><p>In a method which takes pointers as arguments,
one of the pointer arguments is <code>NULL</code>,
in a case where that is not allowed. 
One such method is <code>marpa_r_progress_item()</code>. 
Numeric value: 56. 
Suggested message: "An argument is null when it should not be". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_PRECOMPUTED</b><var><a name="index-MARPA_005fERR_005fPRECOMPUTED-173"></a></var><br>
<blockquote><p>An attempt was made to use a precomputed grammar
in a way that is not allowed. 
Often this is an attempt to change the grammar. 
Nearly every change to a grammar after
precomputation invalidates the precomputation,
and is therefore not allowed. 
Numeric value: 57. 
Suggested message: "This grammar is precomputed". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_PROGRESS_REPORT_NOT_STARTED</b><var><a name="index-MARPA_005fERR_005fPROGRESS_005fREPORT_005fNOT_005fSTARTED-174"></a></var><br>
<blockquote><p>No recognizer progress report is currently active,
and an action has been attempted which
is inconsistent with that. 
One such action would be a
<code>marpa_r_progress_item()</code> call. 
Numeric value: 59. 
Suggested message: "No progress report has been started". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_PROGRESS_REPORT_EXHAUSTED</b><var><a name="index-MARPA_005fERR_005fPROGRESS_005fREPORT_005fEXHAUSTED-175"></a></var><br>
<blockquote><p>The progress report is &ldquo;exhausted&rdquo; &mdash; all its
items have been iterated through. 
Numeric value: 58. 
Suggested message: "The progress report is exhausted". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_RANK_TOO_LOW</b><var><a name="index-MARPA_005fERR_005fRANK_005fTOO_005fLOW-176"></a></var><br>
<blockquote><p>A symbol or rule rank was specified which
was less than an implementation-defined minimum. 
Implementations will always allow at least those
ranks in the range between
&minus;134,217,727 and 134,217,727. 
Numeric value: 85. 
Suggested message: "Rule or symbol rank too low". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_RANK_TOO_HIGH</b><var><a name="index-MARPA_005fERR_005fRANK_005fTOO_005fHIGH-177"></a></var><br>
<blockquote><p>A symbol or rule rank was specified which
was greater than an implementation-defined maximum. 
Implementations will always allow at least those
ranks in the range between
&minus;134,217,727 and 134,217,727. 
Numeric value: 86. 
Suggested message: "Rule or symbol rank too high". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_RECCE_IS_INCONSISTENT</b><var><a name="index-MARPA_005fERR_005fRECCE_005fIS_005fINCONSISTENT-178"></a></var><br>
<blockquote><p>The recognizer is &ldquo;inconsistent&rdquo;,
usually because the user has rejected one or
more rules or terminals,
and has not yet called
the  <code>marpa_r_consistent()</code> method. 
Numeric value: 95. 
Suggested message: "The recognizer is inconsistent. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_RECCE_NOT_ACCEPTING_INPUT</b><var><a name="index-MARPA_005fERR_005fRECCE_005fNOT_005fACCEPTING_005fINPUT-179"></a></var><br>
<blockquote><p>The recognizer is not accepting input,
and the application has attempted something that
is inconsistent with that fact. 
Numeric value: 60. 
Suggested message: "The recognizer is not accepting input". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_RECCE_NOT_STARTED</b><var><a name="index-MARPA_005fERR_005fRECCE_005fNOT_005fSTARTED-180"></a></var><br>
<blockquote><p>The recognizer has not been started. 
and the application has attempted something that
is inconsistent with that fact. 
Numeric value: 61. 
Suggested message: "The recognizer has not been started". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_RECCE_STARTED</b><var><a name="index-MARPA_005fERR_005fRECCE_005fSTARTED-181"></a></var><br>
<blockquote><p>The recognizer has been started. 
and the application has attempted something that
is inconsistent with that fact. 
Numeric value: 62. 
Suggested message: "The recognizer has been started". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_RHS_IX_NEGATIVE</b><var><a name="index-MARPA_005fERR_005fRHS_005fIX_005fNEGATIVE-182"></a></var><br>
<blockquote><p>The index of a RHS symbol was specified,
and it was negative. 
That is not allowed. 
Numeric value: 63. 
Suggested message: "RHS index cannot be negative". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_RHS_IX_OOB</b><var><a name="index-MARPA_005fERR_005fRHS_005fIX_005fOOB-183"></a></var><br>
<blockquote><p>A non-negative index of RHS symbol was specified,
but there is no symbol at that index. 
Since the indexes are in sequence, this means the
index was greater than or equal to the rule length. 
Numeric value: 64. 
Suggested message: "RHS index must be less than rule length". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_RHS_TOO_LONG</b><var><a name="index-MARPA_005fERR_005fRHS_005fTOO_005fLONG-184"></a></var><br>
<blockquote><p>An attempt was made to add a rule with too many
right hand side symbols. 
The limit on the RHS symbol count is implementation
dependent, but it is very large,
at least 500,000,000 symbols. 
This is
far beyond what is required in any current practical grammar. 
An application with rules of this length is almost
certain to run into memory and other limits. 
Numeric value: 65. 
Suggested message: "The RHS is too long". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_SEQUENCE_LHS_NOT_UNIQUE</b><var><a name="index-MARPA_005fERR_005fSEQUENCE_005fLHS_005fNOT_005fUNIQUE-185"></a></var><br>
<blockquote><p>The LHS of a
sequence rule cannot be the LHS of any other rule,
whether a sequence rule or a BNF rule. 
An attempt was made to violate this restriction. 
Numeric value: 66. 
Suggested message: "LHS of sequence rule would not be unique". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_START_NOT_LHS</b><var><a name="index-MARPA_005fERR_005fSTART_005fNOT_005fLHS-186"></a></var><br>
<blockquote><p>The start symbol is not on the LHS on
any rule. 
That means it could never match any possible input,
not even the null string. 
Presumably, an error in writing the grammar. 
Numeric value: 73. 
Suggested message: "Start symbol not on LHS of any rule". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_SYMBOL_IS_NOT_COMPLETION_EVENT</b><var><a name="index-MARPA_005fERR_005fSYMBOL_005fIS_005fNOT_005fCOMPLETION_005fEVENT-187"></a></var><br>
<blockquote><p>An attempt was made to use a symbol in
a way that requires it to be
set up for completion events,
but the symbol was not set
set up for completion events. 
The archtypal case is an attempt to activate completion
events for the symbol in the recognizer. 
The archtypal case is an attempt to activate a completion
event in the recognizer for
a symbol that is not set up as a completion event. 
Numeric value: 92. 
Suggested message: "Symbol is not set up for completion events". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_SYMBOL_IS_NOT_NULLED_EVENT</b><var><a name="index-MARPA_005fERR_005fSYMBOL_005fIS_005fNOT_005fNULLED_005fEVENT-188"></a></var><br>
<blockquote><p>An attempt was made to use a symbol in
a way that requires it to be
set up for nulled events,
but the symbol was not set
set up for nulled events. 
The archtypal case is an attempt to activate a nulled
events in the recognizer for
a symbol that is not set up as a nulled event. 
Numeric value: 93. 
Suggested message: "Symbol is not set up for nulled events". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_SYMBOL_IS_NOT_PREDICTION_EVENT</b><var><a name="index-MARPA_005fERR_005fSYMBOL_005fIS_005fNOT_005fPREDICTION_005fEVENT-189"></a></var><br>
<blockquote><p>An attempt was made to use a symbol in
a way that requires it to be
set up for predictino events,
but the symbol was not set
set up for predictino events. 
The archtypal case is an attempt to activate a prediction
event in the recognizer for
a symbol that is not set up as a prediction event. 
Numeric value: 94. 
Suggested message: "Symbol is not set up for prediction events". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_SYMBOL_VALUED_CONFLICT</b><var><a name="index-MARPA_005fERR_005fSYMBOL_005fVALUED_005fCONFLICT-190"></a></var><br>
<blockquote><p>Unvalued symbols are a deprecated Marpa feature,
which may be avoided with
the <code>marpa_g_force_valued</code> method. 
An unvalued symbol may take on any value,
and therefore a symbol which is unvalued at some points
cannot safely to be used to contain a value at
others. 
This error indicates that such an unsafe use is
being attempted. 
Numeric value: 74. 
Suggested message: "Symbol is treated both as valued and unvalued". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_TERMINAL_IS_LOCKED</b><var><a name="index-MARPA_005fERR_005fTERMINAL_005fIS_005fLOCKED-191"></a></var><br>
<blockquote><p>An attempt was made to change the terminal status
of a symbol to a different value
after it was locked. 
Numeric value: 75. 
Suggested message: "The terminal status of the symbol is locked". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_TOKEN_IS_NOT_TERMINAL</b><var><a name="index-MARPA_005fERR_005fTOKEN_005fIS_005fNOT_005fTERMINAL-192"></a></var><br>
<blockquote><p>A token was specified whose symbol ID is not
a terminal. 
Numeric value: 76. 
Suggested message: "Token symbol must be a terminal". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_TOKEN_LENGTH_LE_ZERO</b><var><a name="index-MARPA_005fERR_005fTOKEN_005fLENGTH_005fLE_005fZERO-193"></a></var><br>
<blockquote><p>A token length was specified which is less than
or equal to zero. 
Zero-length tokens are not allowed in Libmarpa. 
Numeric value: 77. 
Suggested message: "Token length must greater than zero". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_TOKEN_TOO_LONG</b><var><a name="index-MARPA_005fERR_005fTOKEN_005fTOO_005fLONG-194"></a></var><br>
<blockquote><p>The token length is too long. 
The limit on the length of a token
is implementation dependent, but it
is at least 500,000,000 earlemes. 
An application using a token that long
is almost certain to run into some other
limit. 
Numeric value: 78. 
Suggested message: "Token is too long". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_TREE_EXHAUSTED</b><var><a name="index-MARPA_005fERR_005fTREE_005fEXHAUSTED-195"></a></var><br>
<blockquote><p>A Libmarpa parse tree iterator
is &ldquo;exhausted&rdquo;, that is,
it has no more parses. 
Numeric value: 79. 
Suggested message: "Tree iterator is exhausted". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_TREE_PAUSED</b><var><a name="index-MARPA_005fERR_005fTREE_005fPAUSED-196"></a></var><br>
<blockquote><p>A Libmarpa tree is &ldquo;paused&rdquo;
and an operation was attempted which
is inconsistent with that fact. 
Typically, this operation will be
a call of the <code>marpa_t_next()</code> method. 
Numeric value: 80. 
Suggested message: "Tree iterator is paused". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_UNEXPECTED_TOKEN_ID</b><var><a name="index-MARPA_005fERR_005fUNEXPECTED_005fTOKEN_005fID-197"></a></var><br>
<blockquote><p>An attempt was made to read a token
where a token with that symbol ID is not
expected. 
This message can also occur when an
attempt is made to read a token
at a location where no token is expected. 
Numeric value: 81. 
Suggested message: "Unexpected token". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_UNPRODUCTIVE_START</b><var><a name="index-MARPA_005fERR_005fUNPRODUCTIVE_005fSTART-198"></a></var><br>
<blockquote><p>The start symbol is unproductive. 
That means it could never match any possible input,
not even the null string. 
Presumably, an error in writing the grammar. 
Numeric value: 82. 
Suggested message: "Unproductive start symbol". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_VALUATOR_INACTIVE</b><var><a name="index-MARPA_005fERR_005fVALUATOR_005fINACTIVE-199"></a></var><br>
<blockquote><p>The valuator is inactive in a context where that
should not be the case. 
Numeric value: 83. 
Suggested message: "Valuator inactive". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_VALUED_IS_LOCKED</b><var><a name="index-MARPA_005fERR_005fVALUED_005fIS_005fLOCKED-200"></a></var><br>
<blockquote><p>Unvalued symbols are a deprecated Marpa feature,
which may be avoided with
the <code>marpa_g_force_valued</code> method. 
This error code
indicates that the valued status of a symbol is locked,
and an attempt was made
to change it to a status different from the
current one. 
Numeric value: 84. 
Suggested message: "The valued status of the symbol is locked". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_SYMBOL_IS_NULLING</b><var><a name="index-MARPA_005fERR_005fSYMBOL_005fIS_005fNULLING-201"></a></var><br>
<blockquote><p>An attempt was made to do something with a nulling
symbol that is not allowed. 
For example,
the ID of a nulling symbol cannot be an argument
to <code>marpa_r_expected_symbol_event_set</code> &mdash;
because it is not possible to create an &ldquo;expected symbol&rdquo; event
for a nulling symbol. 
Numeric value: 87. 
Suggested message: "Symbol is nulling". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_SYMBOL_IS_UNUSED</b><var><a name="index-MARPA_005fERR_005fSYMBOL_005fIS_005fUNUSED-202"></a></var><br>
<blockquote><p>An attempt was made to do something with a nulling
symbol that is not allowed. 
An &ldquo;unused&rdquo; symbol is a inaccessible or unproductive symbol. 
For example,
the ID of a unused symbol cannot be an argument
to <code>marpa_r_expected_symbol_event_set</code> &mdash;
because it is not possible to create an &ldquo;expected symbol&rdquo; event
for a nulling symbol. 
Numeric value: 88. 
Suggested message: "Symbol is not used". 
</p></blockquote></div>

<p><a name="Internal-error-codes"></a>

<h3 class="section">19.4 Internal error codes</h3>

<p>An internal error code may be one of two things:
First,
it can be an error code which
arises from an internal Libmarpa programming issue
(in other words, something happening in the code
that was not supposed to be able to happen.) 
Second, it can be an error code which only occurs
when a method from Libmarpa's internal interface
is used. 
Both kinds of internal error message share one common
trait &mdash; users of the Libmarpa's external interface
should never see them.

   <p>Internal error messages
require someone with knowledge of the Libmarpa internals
to follow up on them. 
They usually do not have descriptions or suggested messages.

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_AHFA_IX_NEGATIVE</b><var><a name="index-MARPA_005fERR_005fAHFA_005fIX_005fNEGATIVE-203"></a></var><br>
<blockquote><p>Numeric value: 1. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_AHFA_IX_OOB</b><var><a name="index-MARPA_005fERR_005fAHFA_005fIX_005fOOB-204"></a></var><br>
<blockquote><p>Numeric value: 2. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_ANDID_NEGATIVE</b><var><a name="index-MARPA_005fERR_005fANDID_005fNEGATIVE-205"></a></var><br>
<blockquote><p>Numeric value: 3. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_ANDID_NOT_IN_OR</b><var><a name="index-MARPA_005fERR_005fANDID_005fNOT_005fIN_005fOR-206"></a></var><br>
<blockquote><p>Numeric value: 4. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_ANDIX_NEGATIVE</b><var><a name="index-MARPA_005fERR_005fANDIX_005fNEGATIVE-207"></a></var><br>
<blockquote><p>Numeric value: 5. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_BOCAGE_ITERATION_EXHAUSTED</b><var><a name="index-MARPA_005fERR_005fBOCAGE_005fITERATION_005fEXHAUSTED-208"></a></var><br>
<blockquote><p>Numeric value: 7. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_DEVELOPMENT</b><var><a name="index-MARPA_005fERR_005fDEVELOPMENT-209"></a></var><br>
<blockquote><p>"Development" errors were used heavily during
Libmarpa's development,
when it was not yet clear how precisely
to classify every error condition. 
Unless they are using a developer's version,
users of the external interface
should never
see development errors.

        <p>Development errors have an error string
associated with them. 
The error string is a
short 7-bit ASCII error string
which describes the error. 
Numeric value: 9. 
Suggested message: "Development error, see string". 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_DUPLICATE_AND_NODE</b><var><a name="index-MARPA_005fERR_005fDUPLICATE_005fAND_005fNODE-210"></a></var><br>
<blockquote><p>Numeric value: 10. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_YIM_ID_INVALID</b><var><a name="index-MARPA_005fERR_005fYIM_005fID_005fINVALID-211"></a></var><br>
<blockquote><p>Numeric value: 14. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_INTERNAL</b><var><a name="index-MARPA_005fERR_005fINTERNAL-212"></a></var><br>
<blockquote><p>A &ldquo;catchall&rdquo; internal error. 
Numeric value: 19. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_INVALID_AHFA_ID</b><var><a name="index-MARPA_005fERR_005fINVALID_005fAHFA_005fID-213"></a></var><br>
<blockquote><p>The AHFA ID was invalid.  There are no AHFAs
any more, so this message should not occur. 
Numeric value: 20. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_INVALID_AIMID</b><var><a name="index-MARPA_005fERR_005fINVALID_005fAIMID-214"></a></var><br>
<blockquote><p>The AHM ID was invalid.  The term &ldquo;AIMID&rdquo;
is a legacy of earlier implementations and must
be kept for backward compatibility. 
Numeric value: 21.

        </blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_INVALID_IRLID</b><var><a name="index-MARPA_005fERR_005fINVALID_005fIRLID-215"></a></var><br>
<blockquote><p>Numeric value: 23. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_INVALID_NSYID</b><var><a name="index-MARPA_005fERR_005fINVALID_005fNSYID-216"></a></var><br>
<blockquote><p>Numeric value: 24. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NOOKID_NEGATIVE</b><var><a name="index-MARPA_005fERR_005fNOOKID_005fNEGATIVE-217"></a></var><br>
<blockquote><p>Numeric value: 33. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NOT_TRACING_COMPLETION_LINKS</b><var><a name="index-MARPA_005fERR_005fNOT_005fTRACING_005fCOMPLETION_005fLINKS-218"></a></var><br>
<blockquote><p>Numeric value: 35. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NOT_TRACING_LEO_LINKS</b><var><a name="index-MARPA_005fERR_005fNOT_005fTRACING_005fLEO_005fLINKS-219"></a></var><br>
<blockquote><p>Numeric value: 36. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NOT_TRACING_TOKEN_LINKS</b><var><a name="index-MARPA_005fERR_005fNOT_005fTRACING_005fTOKEN_005fLINKS-220"></a></var><br>
<blockquote><p>Numeric value: 37. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_AND_NODES</b><var><a name="index-MARPA_005fERR_005fNO_005fAND_005fNODES-221"></a></var><br>
<blockquote><p>Numeric value: 38. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_OR_NODES</b><var><a name="index-MARPA_005fERR_005fNO_005fOR_005fNODES-222"></a></var><br>
<blockquote><p>Numeric value: 40. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_TRACE_YS</b><var><a name="index-MARPA_005fERR_005fNO_005fTRACE_005fYS-223"></a></var><br>
<blockquote><p>Numeric value: 46. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_TRACE_PIM</b><var><a name="index-MARPA_005fERR_005fNO_005fTRACE_005fPIM-224"></a></var><br>
<blockquote><p>Numeric value: 47. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_TRACE_YIM</b><var><a name="index-MARPA_005fERR_005fNO_005fTRACE_005fYIM-225"></a></var><br>
<blockquote><p>Numeric value: 45. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_NO_TRACE_SRCL</b><var><a name="index-MARPA_005fERR_005fNO_005fTRACE_005fSRCL-226"></a></var><br>
<blockquote><p>Numeric value: 48. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_ORID_NEGATIVE</b><var><a name="index-MARPA_005fERR_005fORID_005fNEGATIVE-227"></a></var><br>
<blockquote><p>Numeric value: 51. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_OR_ALREADY_ORDERED</b><var><a name="index-MARPA_005fERR_005fOR_005fALREADY_005fORDERED-228"></a></var><br>
<blockquote><p>Numeric value: 52. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_PIM_IS_NOT_LIM</b><var><a name="index-MARPA_005fERR_005fPIM_005fIS_005fNOT_005fLIM-229"></a></var><br>
<blockquote><p>Numeric value: 55. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_SOURCE_TYPE_IS_NONE</b><var><a name="index-MARPA_005fERR_005fSOURCE_005fTYPE_005fIS_005fNONE-230"></a></var><br>
<blockquote><p>Numeric value: 70. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_SOURCE_TYPE_IS_TOKEN</b><var><a name="index-MARPA_005fERR_005fSOURCE_005fTYPE_005fIS_005fTOKEN-231"></a></var><br>
<blockquote><p>Numeric value: 71. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_SOURCE_TYPE_IS_COMPLETION</b><var><a name="index-MARPA_005fERR_005fSOURCE_005fTYPE_005fIS_005fCOMPLETION-232"></a></var><br>
<blockquote><p>Numeric value: 68. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_SOURCE_TYPE_IS_LEO</b><var><a name="index-MARPA_005fERR_005fSOURCE_005fTYPE_005fIS_005fLEO-233"></a></var><br>
<blockquote><p>Numeric value: 69. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_SOURCE_TYPE_IS_AMBIGUOUS</b><var><a name="index-MARPA_005fERR_005fSOURCE_005fTYPE_005fIS_005fAMBIGUOUS-234"></a></var><br>
<blockquote><p>Numeric value: 67. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>MARPA_ERR_SOURCE_TYPE_IS_UNKNOWN</b><var><a name="index-MARPA_005fERR_005fSOURCE_005fTYPE_005fIS_005fUNKNOWN-235"></a></var><br>
<blockquote><p>Numeric value: 72. 
</p></blockquote></div>

<p><a name="Design-notes"></a>

<h2 class="chapter">20 Design notes</h2>

<p>Design apologetics are
throughout this document,
dispersed among sections where it is
hoped that they motivate the description or discussion. 
The notes in this section
did not find a home elsewhere.

<p><a name="Why-so-many-time-objects"></a>

<h3 class="section">20.1 Why so many time objects?</h3>

<p>Marpa is an aggressively multi-pass algorithm. 
Marpa achieves its efficiency,
not in spite of making multiple
passes over the data, but because of it. 
Marpa regularly substitutes
two fast O(<var>n</var>) passes for a single
O(<var>n</var> log <var>n</var>) pass. 
Marpa's proliferation of time objects is in
keeping with its multi-pass approach.

   <p>Bocage objects come at no cost,
even for unambiguous parses,
because the same pass which creates the bocage
also deals with other issues which are of major
significance for unambiguous parses. 
It is the post-processing of the bocage pass
that enables Marpa to do both left-
and right-recursion in linear time.

   <p>Of the various objects, the best
case for elimination is of the
ordering object. 
In many cases, the ordering is trivial. 
Either the parse is unambiguous, or the
application does not care about the order in
which parses are returned. 
But while it would be easy to add an option
to bypass creation of an ordering object,
there is little to be gained from it. 
When the ordering is trivial,
its overhead is very small &mdash;
essentially a handful of subroutine calls. 
Many orderings accomplish nothing,
but these cost next to nothing.

   <p>Tree objects come at minimal cost to unambiguous grammars,
because the same pass that allows iteration through multiple
parse trees does the tree traversal. 
This eliminates much of the work that otherwise would
need to be done in
the valuation time object. 
In the current implement, the valuation time object
needs only to step through a sequence already determined
in the tree iterator.

<p><a name="Design-of-numbered-objects"></a>

<h3 class="section">20.2 Numbered objects</h3>

<p>As the name suggests,
the choice was made to implement
numbered objects as integers,
and not as
pointers. 
In standard-conformant C,
integers can be safely checked for validity,
while pointers cannot.

   <p>There are efficiency tradeoffs between pointers and
integers but they are complicated,
and they go both ways. 
Pointers can be faster, but integers can be used
as indexes into more than one data structure. 
Which is actually faster depends on the design. 
Integers allow for a more flexible design,
so that once the choice is settled on,
careful programming can make them a win,
possibly a very big one.

   <p>The approach taken in Libmarpa was to settle,
from the outset,
on integers as the implementation for numbered
objects,
and to optimize on that basis. 
The author concedes that it is
possible that
others redoing Libmarpa from scratch
might find that pointers are faster. 
But the author is confident
that they will also discover,
on modern architectures,
that the lack of safe validity checking
is far too high a price to pay
for the difference in speed.

<p><a name="LHS-Terminals"></a>

<h3 class="section">20.3 LHS terminals</h3>

<p>Marpa's idea
in losing the sharp division between terminals
and non-terminals is that the distinction,
while helpful for proving theorems,
is not essential in practice. 
LHS symbols
in the input might be useful for
&ldquo;short circuiting&rdquo; the rules in which they occur. 
This may
prove helpful in debugging, or have other applications.

   <p>However,
it also can be useful,
for checking input validity as well as for efficiency,
to follow tradition and distinguish
non-terminals from terminals. 
For this reason,
the traditional behavior is the default
in Libmarpa.

<p><a name="Work-in-Progress"></a>

<h2 class="chapter">21 Work in Progress</h2>

<p><a name="Untested-methods"></a>

<h3 class="section">21.1 Untested methods</h3>

<p>The methods of this section are not in the external interface,
because they have not been adequately tested. 
Their fate is uncertain. 
Users should regard these methods
as unsupported.

<p><a name="Ranking-methods"></a>

<h4 class="subsection">21.1.1 Ranking methods</h4>

<div class="defun">
&mdash; Function: Marpa_Rank <b>marpa_g_default_rank</b> (<var> Marpa_Grammar g</var>)<var><a name="index-marpa_005fg_005fdefault_005frank-236"></a></var><br>
&mdash; Function: Marpa_Rank <b>marpa_g_default_rank_set</b> (<var> Marpa_Grammar g, Marpa_Rank rank</var>)<var><a name="index-marpa_005fg_005fdefault_005frank_005fset-237"></a></var><br>
<blockquote>
        <p>These methods, respectively, set
and query the default rank of the grammar. 
When a grammar is created, the default rank is 0. 
When rules and symbols are created, their rank is
the default rank of the grammar.

        <p>Changing the grammar's default rank does not affect
those
rules and symbols already created,
only those that will be created. 
This means that
the grammar's default rank can be used to,
in effect, assign ranks to groups of rules and symbols. 
Applications may find this behavior useful.

        <p>Return value: On success, returns
the rank <strong>after</strong>
the call,
and sets the error code to
<code>MARPA_ERR_NONE</code>. 
On failure, returns &minus;2,
and sets the error code to an appropriate
value, which will never be
<code>MARPA_ERR_NONE</code>. 
Note that when the rank is &minus;2,
the error code is the only way to distinguish
success from failure. 
The error code can be determined by using the
<code>marpa_g_error()</code> call.

     </blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Rank <b>marpa_g_symbol_rank</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID sym_id</var>)<var><a name="index-marpa_005fg_005fsymbol_005frank-238"></a></var><br>
&mdash; Function: Marpa_Rank <b>marpa_g_symbol_rank_set</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID sym_id, Marpa_Rank rank</var>)<var><a name="index-marpa_005fg_005fsymbol_005frank_005fset-239"></a></var><br>
<blockquote>
        <p>These methods, respectively, set
and query the rank of a symbol <var>sym_id</var>. 
When <var>sym_id</var> is created, its rank
initialized to the default rank of the grammar.

        <p>Return value: On success, returns
the rank <strong>after</strong>
the call,
and sets the error code to
<code>MARPA_ERR_NONE</code>. 
On failure, returns &minus;2,
and sets the error code to an appropriate
value, which will never be
<code>MARPA_ERR_NONE</code>. 
Note that when the rank is &minus;2,
the error code is the only way to distinguish
success from failure. 
The error code can be determined by using the
<code>marpa_g_error()</code> call.

        </blockquote></div>

<p><a name="Zero-width-assertion-methods"></a>
<a name="Zero_002dwidth-assertion-methods"></a>

<h4 class="subsection">21.1.2 Zero-width assertion methods</h4>

<div class="defun">
&mdash; Function: Marpa_Assertion_ID <b>marpa_g_zwa_new</b> (<var> Marpa_Grammar g, int default_value</var>)<var><a name="index-marpa_005fg_005fzwa_005fnew-240"></a></var><br>
     </div>

<div class="defun">
&mdash; Function: int <b>marpa_g_zwa_place</b> (<var> Marpa_Grammar g, Marpa_Assertion_ID zwaid, Marpa_Rule_ID xrl_id, int rhs_ix</var>)<var><a name="index-marpa_005fg_005fzwa_005fplace-241"></a></var><br>
        </div>

<div class="defun">
&mdash; Function: int <b>marpa_r_zwa_default</b> (<var> Marpa_Recognizer r, Marpa_Assertion_ID zwaid</var>)<var><a name="index-marpa_005fr_005fzwa_005fdefault-242"></a></var><br>
<blockquote>
        <p>On success, returns previous default value of the assertion. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_r_zwa_default_set</b> (<var> Marpa_Recognizer r, Marpa_Assertion_ID zwaid, int default_value</var>)<var><a name="index-marpa_005fr_005fzwa_005fdefault_005fset-243"></a></var><br>
<blockquote>
        <p>Changes default value to <var>default_value</var>. 
On success, returns previous default value of the assertion. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: Marpa_Assertion_ID <b>marpa_g_highest_zwa_id</b> (<var> Marpa_Grammar g </var>)<var><a name="index-marpa_005fg_005fhighest_005fzwa_005fid-244"></a></var><br>
        </div>

<p><a name="Methods-for-revising-parses"></a>

<h4 class="subsection">21.1.3 Methods for revising parses</h4>

<p>Marpa allows an application to &ldquo;change its mind&rdquo; about a parse,
rejected rule previously recognized or predicted,
and terminals previously scanned. 
The methods in this section provide that capability.

<div class="defun">
&mdash; Function: Marpa_Earleme <b>marpa_r_clean</b> (<var> Marpa_Recognizer r</var>)<var><a name="index-marpa_005fr_005fclean-245"></a></var><br>

        </div>

<p><a name="Deprecated-techniques-and-methods"></a>

<h2 class="chapter">22 Deprecated techniques and methods</h2>

<p><a name="Valued-and-unvalued-symbols"></a>

<h3 class="section">22.1 Valued and unvalued symbols</h3>

<p><a name="What-unvalued-symbols-were"></a>

<h4 class="subsection">22.1.1 What unvalued symbols were</h4>

<p>Libmarpa symbols can have values,
which is the traditional way of doing semantics. 
Libmarpa also allows symbols to be unvalued. 
An <dfn>unvalued</dfn> symbol is one whose value
is unpredictable from instance to instance. 
If a symbol is unvalued, we sometimes say that it
has &ldquo;whatever&rdquo; semantics.

   <p>Situations where the semantics can tolerate unvalued symbols
are surprisingly frequent. 
For example, the top-level of many languages is a series
of major units, all of whose semantics are typically accomplished
via side effects. 
The compiler is typically indifferent to the actual value produced
by these major units, and tracking them is a waste of time. 
Similarly, the value of the separators in a list is typically
ignored.

   <p>Rules are unvalued if and only if their LHS symbols
are unvalued. 
When rules and symbols are unvalued,
Libmarpa optimizes their evaluation.

   <p>It is in principle unsafe to check the value
of a symbol if it can be unvalued. 
For this reason,
once a symbol has been treated as valued,
Libmarpa marks it as valued. 
Similarly,
once a symbol has been treated as unvalued,
Libmarpa marks it as unvalued. 
Once marked, a symbol's valued status is
<dfn>locked</dfn> and cannot be changed later.

   <p>The valued status of terminals is marked the first
time they are read. 
The valued status of LHS symbols must be explicitly
marked by the application when initializing the
valuator &mdash; this is Libmarpa's equivalent of
registering a callback.

   <p>LHS terminals are disabled by default. 
If allowed, the user should be aware that the valued
status of a LHS terminal
will be locked in the recognizer
if it is used as a terminal,
and the symbol's use as a rule LHS
in the valuator must be
consistent with the recognizer's marking.

   <p>Marpa reports an error when a symbol's use
conflicts with its locked valued status. 
Doing so usually saves the programmer
some tricky debugging further down the road.

<p><a name="Grammar-methods-dealing-with-unvalued-symbols"></a>

<h4 class="subsection">22.1.2 Grammar methods dealing with unvalued symbols</h4>

<div class="defun">
&mdash; Function: int <b>marpa_g_symbol_is_valued</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID symbol_id</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fvalued-246"></a></var><br>
&mdash; Function: int <b>marpa_g_symbol_is_valued_set</b> (<var> Marpa_Grammar g, Marpa_Symbol_ID symbol_id, int value</var>)<var><a name="index-marpa_005fg_005fsymbol_005fis_005fvalued_005fset-247"></a></var><br>
<blockquote>
        <p>These methods, respectively, set
and query the &ldquo;valued status&rdquo; of a symbol. 
Once set to a value with the
<code>marpa_g_symbol_is_valued_set()</code> method,
the valued status of a symbol is &ldquo;locked&rdquo; at that value. 
It cannot thereafter be changed. 
Subsequent calls to
<code>marpa_g_symbol_is_valued_set()</code>
for the same <var>sym_id</var> will fail,
leaving <var>sym_id</var>'s valued status unchanged,
unless <var>value</var> is the same as the locked-in value.

        <p>Return value: On success, 1 if the symbol <var>symbol_id</var>
is valued after the call, 0 if not. 
If the valued status is locked and <var>value</var>
is different from the current status, &minus;2. 
If <var>value</var> is not 0 or 1;
or on other failure, &minus;2.

     </blockquote></div>

<p><a name="Registering-semantics-in-the-valuator"></a>

<h4 class="subsection">22.1.3 Registering semantics in the valuator</h4>

<p>By default, Libmarpa's valuator objects
assume that
non-terminal symbols have
no semantics. 
The archetypal application will need to register
symbols that contain semantics. 
The primary method for doing this is
<code>marpa_v_symbol_is_valued()</code>. 
Applications will typically register semantics by rule,
and these applications will find
the <code>marpa_v_rule_is_valued()</code> method more convenient.

<div class="defun">
&mdash; Function: int <b>marpa_v_symbol_is_valued</b> (<var> Marpa_Value v, Marpa_Symbol_ID sym_id </var>)<var><a name="index-marpa_005fv_005fsymbol_005fis_005fvalued-248"></a></var><br>
&mdash; Function: int <b>marpa_v_symbol_is_valued_set</b> (<var> Marpa_Value v, Marpa_Symbol_ID sym_id, int value </var>)<var><a name="index-marpa_005fv_005fsymbol_005fis_005fvalued_005fset-249"></a></var><br>
<blockquote><p>These methods, respectively,
discover and set to <var>value</var>,
the valued status for symbol <var>sym_id</var>. 
A valued status of 1 indicates that the symbol is valued. 
A valued status of 0 indicates that the symbol is unvalued. 
If the valued status is locked,
an attempt to change to a status different from the
current one will fail
(error code <code>MARPA_ERR_VALUED_IS_LOCKED</code>).

        <p>Return value:  On success, the valued status <strong>after</strong>
the call. 
If <var>value</var> is not either 0 or 1,
or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_v_rule_is_valued</b> (<var> Marpa_Value v, Marpa_Rule_ID rule_id </var>)<var><a name="index-marpa_005fv_005frule_005fis_005fvalued-250"></a></var><br>
&mdash; Function: int <b>marpa_v_rule_is_valued_set</b> (<var> Marpa_Value v, Marpa_Rule_ID rule_id, int value </var>)<var><a name="index-marpa_005fv_005frule_005fis_005fvalued_005fset-251"></a></var><br>
<blockquote><p>These methods respectively,
discover and set to <var>value</var>,
the valued status
for the LHS symbol of rule <var>rule_id</var>. 
A valued status of 1 indicates that the symbol is valued. 
A valued status of 0 indicates that the symbol is unvalued. 
If the valued status is locked,
an attempt to change to a status different from the
current one will fail
(error code <code>MARPA_ERR_VALUED_IS_LOCKED</code>).

        <p>Rules have no valued status of their own. 
The valued status of a rule
is always that of its LHS symbol. 
These methods are conveniences &mdash; they
save the application the trouble of looking
up the rule's LHS.

        <p>Return value:  On success, the valued status of the
rule <var>rule_id</var>'s LHS symbol <strong>after</strong>
the call. 
If <var>value</var> is not either 0 or 1,
or on other failure, &minus;2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>marpa_v_valued_force</b> (<var> Marpa_Value v</var>)<var><a name="index-marpa_005fv_005fvalued_005fforce-252"></a></var><br>
<blockquote>
        <p>This methods locks the valued status of all symbols
to 1, indicated that the symbol is valued. 
If this is not possible, for example because one of
the grammar's symbols already is locked at a valued
status of 0,
failure is returned.

        <p>Return value: On success, a non-negative number. 
On failure, returns &minus;2,
and sets the error code to an appropriate
value, which will never be
<code>MARPA_ERR_NONE</code>.

        </blockquote></div>

<p><a name="GNU-Free-Documentation-License"></a>

<h2 class="appendix">Appendix A GNU Free Documentation License</h2>

<!-- The GNU Free Documentation License. -->
<div align="center">Version 1.3, 3 November 2008</div>

<!-- This file is intended to be included within another document, -->
<!-- hence no sectioning command or @node. -->
<pre class="display">     Copyright &copy; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <a href="http://fsf.org/">http://fsf.org/</a>
     
     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.
</pre>
     <ol type=1 start=0>
<li>PREAMBLE

     <p>The purpose of this License is to make a manual, textbook, or other
functional and useful document <dfn>free</dfn> in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially. 
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.

     <p>This License is a kind of &ldquo;copyleft&rdquo;, which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.

     <p>We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.

     <li>APPLICABILITY AND DEFINITIONS

     <p>This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The &ldquo;Document&rdquo;, below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as &ldquo;you&rdquo;.  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.

     <p>A &ldquo;Modified Version&rdquo; of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

     <p>A &ldquo;Secondary Section&rdquo; is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.

     <p>The &ldquo;Invariant Sections&rdquo; are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.

     <p>The &ldquo;Cover Texts&rdquo; are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.

     <p>A &ldquo;Transparent&rdquo; copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent. 
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not &ldquo;Transparent&rdquo; is called &ldquo;Opaque&rdquo;.

     <p>Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input
format, SGML or XML using a publicly available
DTD, and standard-conforming simple HTML,
PostScript or PDF designed for human modification.  Examples
of transparent image formats include PNG, XCF and
JPG.  Opaque formats include proprietary formats that can be
read and edited only by proprietary word processors, SGML or
XML for which the DTD and/or processing tools are
not generally available, and the machine-generated HTML,
PostScript or PDF produced by some word processors for
output purposes only.

     <p>The &ldquo;Title Page&rdquo; means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, &ldquo;Title Page&rdquo; means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.

     <p>The &ldquo;publisher&rdquo; means any person or entity that distributes copies
of the Document to the public.

     <p>A section &ldquo;Entitled XYZ&rdquo; means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as &ldquo;Acknowledgements&rdquo;,
&ldquo;Dedications&rdquo;, &ldquo;Endorsements&rdquo;, or &ldquo;History&rdquo;.)  To &ldquo;Preserve the Title&rdquo;
of such a section when you modify the Document means that it remains a
section &ldquo;Entitled XYZ&rdquo; according to this definition.

     <p>The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.

     <li>VERBATIM COPYING

     <p>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

     <p>You may also lend copies, under the same conditions stated above, and
you may publicly display copies.

     <li>COPYING IN QUANTITY

     <p>If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition. 
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.

     <p>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

     <p>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material. 
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.

     <p>It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.

     <li>MODIFICATIONS

     <p>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:

          <ol type=A start=1>
<li>Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.

          <li>List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has fewer than five),
unless they release you from this requirement.

          <li>State on the Title page the name of the publisher of the
Modified Version, as the publisher.

          <li>Preserve all the copyright notices of the Document.

          <li>Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.

          <li>Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.

          <li>Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document's license notice.

          <li>Include an unaltered copy of this License.

          <li>Preserve the section Entitled &ldquo;History&rdquo;, Preserve its Title, and add
to it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section Entitled &ldquo;History&rdquo; in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

          <li>Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the &ldquo;History&rdquo; section. 
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.

          <li>For any section Entitled &ldquo;Acknowledgements&rdquo; or &ldquo;Dedications&rdquo;, Preserve
the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgements and/or
dedications given therein.

          <li>Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.

          <li>Delete any section Entitled &ldquo;Endorsements&rdquo;.  Such a section
may not be included in the Modified Version.

          <li>Do not retitle any existing section to be Entitled &ldquo;Endorsements&rdquo; or
to conflict in title with any Invariant Section.

          <li>Preserve any Warranty Disclaimers.
          </ol>

     <p>If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice. 
These titles must be distinct from any other section titles.

     <p>You may add a section Entitled &ldquo;Endorsements&rdquo;, provided it contains
nothing but endorsements of your Modified Version by various
parties&mdash;for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.

     <p>You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.

     <p>The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.

     <li>COMBINING DOCUMENTS

     <p>You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.

     <p>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number. 
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

     <p>In the combination, you must combine any sections Entitled &ldquo;History&rdquo;
in the various original documents, forming one section Entitled
&ldquo;History&rdquo;; likewise combine any sections Entitled &ldquo;Acknowledgements&rdquo;,
and any sections Entitled &ldquo;Dedications&rdquo;.  You must delete all
sections Entitled &ldquo;Endorsements.&rdquo;

     <li>COLLECTIONS OF DOCUMENTS

     <p>You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

     <p>You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.

     <li>AGGREGATION WITH INDEPENDENT WORKS

     <p>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an &ldquo;aggregate&rdquo; if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation's users beyond what the individual works permit. 
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.

     <p>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form. 
Otherwise they must appear on printed covers that bracket the whole
aggregate.

     <li>TRANSLATION

     <p>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4. 
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.

     <p>If a section in the Document is Entitled &ldquo;Acknowledgements&rdquo;,
&ldquo;Dedications&rdquo;, or &ldquo;History&rdquo;, the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.

     <li>TERMINATION

     <p>You may not copy, modify, sublicense, or distribute the Document
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense, or distribute it is void, and
will automatically terminate your rights under this License.

     <p>However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.

     <p>Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

     <p>Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, receipt of a copy of some or all of the same material does
not give you any rights to use it.

     <li>FUTURE REVISIONS OF THIS LICENSE

     <p>The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
<a href="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</a>.

     <p>Each version of the License is given a distinguishing version number. 
If the Document specifies that a particular numbered version of this
License &ldquo;or any later version&rdquo; applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.  If the Document
specifies that a proxy can decide which future versions of this
License can be used, that proxy's public statement of acceptance of a
version permanently authorizes you to choose that version for the
Document.

     <li>RELICENSING

     <p>&ldquo;Massive Multiauthor Collaboration Site&rdquo; (or &ldquo;MMC Site&rdquo;) means any
World Wide Web server that publishes copyrightable works and also
provides prominent facilities for anybody to edit those works.  A
public wiki that anybody can edit is an example of such a server.  A
&ldquo;Massive Multiauthor Collaboration&rdquo; (or &ldquo;MMC&rdquo;) contained in the
site means any set of copyrightable works thus published on the MMC
site.

     <p>&ldquo;CC-BY-SA&rdquo; means the Creative Commons Attribution-Share Alike 3.0
license published by Creative Commons Corporation, a not-for-profit
corporation with a principal place of business in San Francisco,
California, as well as future copyleft versions of that license
published by that same organization.

     <p>&ldquo;Incorporate&rdquo; means to publish or republish a Document, in whole or
in part, as part of another Document.

     <p>An MMC is &ldquo;eligible for relicensing&rdquo; if it is licensed under this
License, and if all works that were first published under this License
somewhere other than this MMC, and subsequently incorporated in whole
or in part into the MMC, (1) had no cover texts or invariant sections,
and (2) were thus incorporated prior to November 1, 2008.

     <p>The operator of an MMC Site may republish an MMC contained in the site
under CC-BY-SA on the same site at any time before August 1, 2009,
provided the MMC is eligible for relicensing.

        </ol>

<h3 class="heading">ADDENDUM: How to use this License for your documents</h3>

<p>To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:

<pre class="smallexample">       Copyright (C)  <var>year</var>  <var>your name</var>.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.
</pre>
   <p>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the &ldquo;with<small class="dots">...</small>Texts.&rdquo; line with this:

<pre class="smallexample">         with the Invariant Sections being <var>list their titles</var>, with
         the Front-Cover Texts being <var>list</var>, and with the Back-Cover Texts
         being <var>list</var>.
</pre>
   <p>If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   <p>If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.

<!-- Local Variables: -->
<!-- ispell-local-pdict: "ispell-dict" -->
<!-- End: -->
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33430331-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
  </body>
</html>
